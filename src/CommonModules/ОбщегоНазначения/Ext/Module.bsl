
// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",строка 1,,,строка 2", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" строка1   строка 2", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

	Массив = Новый Массив;

	Массив.Добавить(Тип("Число"));

	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;

	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения служебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(ТекстСообщения, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

// Записывает сообщение в журнал регистрации
Процедура ЗаписатьОшибкуВЖурналРегистрации(Событие, ТекстОшибки) Экспорт
	
	ЗаписьЖурналаРегистрации(Событие, УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		
		Предупреждение(ТекстСообщения);
	
	#Иначе
		
		ВызватьИсключение(ТекстСообщения);
		
	#КонецЕсли
	
КонецПроцедуры // ПредупреждениеОбОшибке()


////////////////////////////////////////////////////////////////////////////////
// СИСТЕМНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ 

Процедура ЗапуститьПрограмму(ПутьКПрограмме, РабочийКаталог = Неопределено) Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		
		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
	
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьПрограмму()

// Получает идентификатор информационной базы.
// Если идентификатор не заполнен, то устанавливает его значение.
// Константа ИдентификаторИнформационнойБазы не должна входить в составы планов обмена и иметь
// различные значения в каждой информационной базе.
//
Функция ИдентификаторИнформационнойБазы() Экспорт
	
	ИдентификаторИнформационнойБазы = Константы.ИдентификаторИнформационнойБазы.Получить();
	
	Если ПустаяСтрока(ИдентификаторИнформационнойБазы) Тогда
		
		ИдентификаторИнформационнойБазы = Новый УникальныйИдентификатор();
		Константы.ИдентификаторИнформационнойБазы.Установить(Строка(ИдентификаторИнформационнойБазы));
		
	КонецЕсли;
	
	Возврат ИдентификаторИнформационнойБазы;
	
КонецФункции
////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
// Серверные процедуры и функции общего назначения:
// - для работы с данными в базе;
// - для работы с прикладными типами и коллекциями значений;
// - математические процедуры и функции;
// - для работы с внешним соединением;
// - для работы с формами;
// - для работы с типами, объектами метаданных и их строковыми представлениями;
// - функции определения типов объектов метаданных;
// - сохранение, чтение и удаление настроек из хранилищ;
// - для работы с табличными документами;
// - для работы с журналом регистрации;
// - для работы в режиме разделения данных;
// - версионирование программных интерфейсов;
// - вспомогательные процедуры и функции.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с данными в базе

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка    - Ссылка на объект - элемент справочника, документ, ...
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		СтруктураРеквизитов = Новый Структура(Реквизиты);
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Структура")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктураРеквизитов = Реквизиты;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		СтруктураРеквизитов = Новый Структура;
		Для каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"),
			Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции 

// Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие, где ключ - ссылка на объект, а Значение - структура, которая 
//				содержит список свойств, как список имен в строке
//				ИменаРеквизитов, со значениям реквизитов, прочитанными
//				из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если ТипЗнч(МассивСсылок) = Тип("Массив") ИЛИ ТипЗнч(МассивСсылок) = Тип("ФиксированныйМассив") Тогда
		Если МассивСсылок.Количество() = 0 Тогда
			Возврат ЗначенияРеквизитов;
		КонецЕсли;
	Иначе
		ОбщегоНазначения.СообщитьОбОшибке("Неверный тип параметра ""МассивСсылок""");
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие, где ключ - ссылка на объект, Значение - значение прочитанного реквизита
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Проверяет проведенность документов
//
// Параметры:
//  Документы - Массив - документы, проведенность которых необходимо проверить
//
// Возвращаемое значение:
//  Массив - непроведенные документы из массива Документы
//
Функция ПроверитьПроведенностьДокументов(знач Документы) Экспорт
	
	Результат = Новый Массив;
	
	ШаблонЗапроса = 	
		"ВЫБРАТЬ
		|	ПсевдонимЗаданнойТаблицы.Ссылка КАК Ссылка
		|ИЗ
		|	&ИмяДокумента КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка В(&МассивДокументов)
		|	И НЕ ПсевдонимЗаданнойТаблицы.Проведен";
	
	ТекстОбъединитьВсе =
		"
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
		
	ИменаДокументов = Новый Массив;
	Для Каждого Документ Из Документы Цикл
		МетаданныеДокумента = Документ.Метаданные();
		Если ИменаДокументов.Найти(МетаданныеДокумента.ПолноеИмя()) = Неопределено
			И Метаданные.Документы.Содержит(МетаданныеДокумента)
			И МетаданныеДокумента.Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
				ИменаДокументов.Добавить(МетаданныеДокумента.ПолноеИмя());
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапроса = "";
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			ТекстЗапроса = ТекстЗапроса + ТекстОбъединитьВсе;
		КонецЕсли;
		ТекстПодзапроса = СтрЗаменить(ШаблонЗапроса, "&ИмяДокумента", ИмяДокумента);
		ТекстЗапроса = ТекстЗапроса + ТекстПодзапроса;
	КонецЦикла;
		
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("МассивДокументов", Документы);
	
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Выполняет попытку проведения документов.
//
// Параметры:
//	Документы                - Массив - документы, которые необходимо провести.
//
// Возвращаемое значение:
//	Массив - массив структур с полями:
//									Ссылка         - документ, который не удалось провести;
//									ОписаниеОшибки - текст описания ошибки при проведении.
//
Функция ПровестиДокументы(Документы) Экспорт
	
	НепроведенныеДокументы = Новый Массив;
	
	Для Каждого ДокументСсылка Из Документы Цикл
		
		ВыполненоУспешно = Ложь;
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		Если ДокументОбъект.ПроверитьЗаполнение() Тогда
			Попытка
				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
				ВыполненоУспешно = Истина;
			Исключение
				ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Проведение документов при печати'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Информация, ДокументОбъект.Метаданные(), ДокументСсылка, 
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		Иначе
			ПредставлениеОшибки = НСтр("ru = 'Поля документа не заполнены.'");
		КонецЕсли;
		
		Если Не ВыполненоУспешно Тогда
			НепроведенныеДокументы.Добавить(Новый Структура("Ссылка,ОписаниеОшибки", ДокументСсылка, ПредставлениеОшибки));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НепроведенныеДокументы;
	
КонецФункции 

// Проверяет наличие ссылок на объект в базе данных.
//
// Параметры:
//  Ссылка       - ЛюбаяСсылка
//               - Массив значений типа ЛюбаяСсылка
//
//  ИскатьСредиСлужебныхОбъектов - Булево - начальное значение Ложь,
//                 когда установлено Истина, тогда не будут учитываться
//                 исключения поиска ссылок, заданные при разработке конфигурации.
//
//  ДругиеИсключения - Массив полных имен объектов метаданных, которые также
//                 требуется исключить из поиска ссылок.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьСсылкиНаОбъект(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь,  ДругиеИсключения = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(СсылкаИлиМассивСсылок) = Тип("Массив") Тогда
		МассивСсылок = СсылкаИлиМассивСсылок;
	Иначе
		МассивСсылок = Новый Массив;
		МассивСсылок.Добавить(СсылкаИлиМассивСсылок);
	КонецЕсли;
	
	ТаблицаСсылок = НайтиПоСсылкам(МассивСсылок);
	ТаблицаСсылок.Колонки[0].Имя = "ИсходнаяСсылка";
	ТаблицаСсылок.Колонки[1].Имя = "ОбнаруженныйСсылка";
	ТаблицаСсылок.Колонки[2].Имя = "ОбнаруженныйМетаданные";
	
	Если НЕ ИскатьСредиСлужебныхОбъектов Тогда
		ИсключенияПоискаСсылок = ПолучитьОбщийСписокИсключенийПоискаСсылок();
		Исключения = Новый Массив;
		
		Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
			ИсключениеПоиска = ИсключенияПоискаСсылок[СтрокаТаблицы.ОбнаруженныйМетаданные];
			Если ИсключениеПоиска = "*" Тогда
				Исключения.Добавить(СтрокаТаблицы);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
	Если ТипЗнч(ДругиеИсключения) = Тип("Массив") Тогда
		ИсключенияПоискаСсылок = Новый Соответствие;
		Исключения = Новый Массив;
		
		Для каждого ПолноеИмя Из ДругиеИсключения Цикл
			ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
			Если ОбъектМетаданных <> Неопределено Тогда
				ИсключенияПоискаСсылок.Вставить(ОбъектМетаданных, "*");
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
			ИсключениеПоиска = ИсключенияПоискаСсылок[СтрокаТаблицы.ОбнаруженныйМетаданные];
			Если ИсключениеПоиска = "*" Тогда
				Исключения.Добавить(СтрокаТаблицы);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаСсылок.Количество() > 0;
	
КонецФункции

// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого Значение Из МассивПриемник Цикл
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла;
	
	Для каждого Значение Из МассивИсточник Цикл
		Если УникальныеЗначения[Значение] = Неопределено Тогда
			МассивПриемник.Добавить(Значение);
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  XML     - текст в формате XML или ЧтениеXML.
//
// Схема XML:
//<?xml version="1.0" encoding="utf-8"?>
//<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
//  <xs:element name="Items">
//	<xs:complexType>
//	  <xs:sequence>
//		<xs:element maxOccurs="unbounded" name="Item">
//		  <xs:complexType>
//			<xs:attribute name="Code" type="xs:integer" use="required" />
//			<xs:attribute name="Name" type="xs:string" use="required" />
//			<xs:attribute name="Socr" type="xs:string" use="required" />
//			<xs:attribute name="Index" type="xs:string" use="required" />
//		  </xs:complexType>
//		</xs:element>
//	  </xs:sequence>
//	  <xs:attribute name="Description" type="xs:string" use="required" />
//	  <xs:attribute name="Columns" type="xs:string" use="required" />
//	</xs:complexType>
//  </xs:element>
//</xs:schema>
//
// Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
//
// Возвращаемое значение:
//  Структура с полями 
//   ИмяТаблицы - Строка
//   Данные - ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(Знач XML) Экспорт
	
	Если ТипЗнч(XML) <> Тип("ЧтениеXML") Тогда
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(XML);
	Иначе
		Чтение = XML;
	КонецЕсли;
	
	// Прочитаем первый узел и проверим его
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение("Ошибка в структуре XML");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента И Чтение.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение("Ошибка в структуре XML");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Сравнивает данные сложной структуры с учетом вложенности.
//
// Параметры:
//  Данные1 - Структура,    ФиксированнаяСтруктура.
//          - Соответствие, ФиксированноеСоответствие.
//          - Массив,       ФиксированныйМассив.
//          - ХранилищеЗначения, ТаблицаЗначений.
//          - Простые типы, которые можно сравнивать на равно,
//            например, Строка, Число, Булево.
//
//  Данные2 - те же типы, что и для параметра Данные1.
//
// Возвращаемое значение:
//  Булево.
//
Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Данные1) = Тип("Структура")
	 ИЛИ ТипЗнч(Данные1) = Тип("ФиксированнаяСтруктура") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			СтароеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение)
			 ИЛИ НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
			
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Соответствие")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированноеСоответствие") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина);
			СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого КлючИЗначение Из Данные2 Цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Массив")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированныйМассив") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Индекс = Данные1.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда
				Возврат Ложь;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ТаблицаЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Индекс = Данные1.Количество()-1;
			Пока Индекс >= 0 Цикл
				Если НЕ ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда
					Возврат Ложь;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ХранилищеЗначения") Тогда
	
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Данные1 = Данные2;
	
КонецФункции

// Фиксирует Данные типов Структура, Соответствие, Массив с учетом вложенности.
//
// Параметры:
//  Данные - Структура, Соответствие, Массив, значения которых являются примитивными типами,
//           хранилищем значения или не могут быть изменены. Поддерживаются типы значений:
//           Булево, Строка, Число, Дата, Неопределено, УникальныйИдентификатор, Null, Тип,
//           ХранилищеЗначения, ОбщийМодуль, ОбъектМетаданных, ТипЗначенияXDTO, ТипОбъектаXDTO,
//           ЛюбаяСсылка.
//
//  ВызыватьИсключение - Булево - начальное значение Истина. Когда установлено
//                       Ложь, тогда в случае наличия нефиксируемых данных исключение не будет
//                       вызвано, при этом данные будут зафиксированы на сколько возможно.
//
// Возвращаемое значение:
//  Фиксированные данные, аналогичные переданным в параметре Данные.
// 
Функция ФиксированныеДанные(Данные, ВызыватьИсключение = Истина) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		Массив = Новый Массив;
		
		Индекс = Данные.Количество() - 1;
		
		Для каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Массив.Добавить(Значение);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Новый ФиксированныйМассив(Массив);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
	      ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Коллекция = Новый Структура;
		Иначе
			Коллекция = Новый Соответствие;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные Цикл
			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(
					КлючИЗначение.Ключ, ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Новый ФиксированнаяСтруктура(Коллекция);
		Иначе
			Возврат Новый ФиксированноеСоответствие(Коллекция);
		КонецЕсли;
		
	ИначеЕсли ВызыватьИсключение Тогда
		ПроверкаФиксированностиДанных(Данные);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешним соединением

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		СистемнаяИнфо.ВерсияПриложения, ".");
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
	
КонецФункции	

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции

// Выполнить экспортную процедуру по имени.
//
// Параметры
//  ИмяЭкспортнойПроцедуры – Строка – имя экспортной процедуры в формате 
//                                    <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                                    общий модуль или модуль менеджера объекта.
// Параметры               - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                                    в порядке расположения элементов массива.
// ОбластьДанных           - Число  - задает область данных, в которой необходимо выполнить процедуру.
// 
// Пример:
//  ВыполнитьБезопасно("МойОбщийМодуль.МояПроцедура");
//
Процедура ВыполнитьБезопасно(ИмяЭкспортнойПроцедуры, Параметры = Неопределено, ОбластьДанных = Неопределено) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.       
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;
		
	Если ЧастиИмени.Количество() = 3 Тогда
		ДопустимыеИменаТипов = Новый Массив;
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОтчеты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаОбработки()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЖурналыДокументов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
		ИмяТипа = ВРег(ЧастиИмени[0]);
		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетода = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка на то, что ИмяМетода является допустимым идентификатором.
		// Например: МояПроцедура
		ВременнаяСтруктура.Вставить(ИмяМетода);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Безопасное выполнение метода'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
	КонецПопытки;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	ВыполненаУстановкаРазделенияСеанса = Ложь;
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Если Не ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
			Если ОбластьДанных = Неопределено Тогда
				ОбластьДанных = ЗначениеРазделителяСеанса();
			Иначе 
				Если ОбластьДанных <> ЗначениеРазделителяСеанса() Тогда
					ВызватьИсключение(НСтр("ru = 'В данном сеансе недопустимо обращение к данным из другой области данных!'"));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ОбластьДанных <> Неопределено
			И (НЕ ИспользованиеРазделителяСеанса() ИЛИ ОбластьДанных <> ЗначениеРазделителяСеанса()) Тогда
			УстановитьРазделениеСеанса(Истина, ОбластьДанных);
			ВыполненаУстановкаРазделенияСеанса = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Выполнить ИмяЭкспортнойПроцедуры + "(" + ПараметрыСтрока + ")";
	
	Если ВыполненаУстановкаРазделенияСеанса Тогда
		УстановитьРазделениеСеанса(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Проверяет имя экспортной процедуры на валидность для использования
// в инструкции Выполнить встроенного языка. При некорректном имени
// вызывается исключение.
//
Функция ПроверитьИмяЭкспортнойПроцедуры(Знач ИмяЭкспортнойПроцедуры, ТекстСообщения) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
		Возврат Ложь;
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
		Возврат Ложь;
	КонецЕсли;
		
	Если ЧастиИмени.Количество() = 3 Тогда
		ДопустимыеИменаТипов = Новый Массив;
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаКонстанты()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыСведений()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыНакопления()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыБухгалтерии()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаРегистрыРасчета()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаСправочники()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаДокументы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаБизнесПроцессы()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаЗадачи()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыСчетов()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыОбмена()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовХарактеристик()));
		ДопустимыеИменаТипов.Добавить(ВРег(ИмяТипаПланыВидовРасчета()));
		ИмяТипа = ВРег(ЧастиИмени[0]);
		Если ДопустимыеИменаТипов.Найти(ИмяТипа) = Неопределено Тогда
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
				ИмяЭкспортнойПроцедуры);
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Формирует соответствие для удаления объектов.
//
Функция ПолучитьОбщийСписокИсключенийПоискаСсылок() Экспорт
	
	МассивИсключенийИзСобытия = Новый Массив;
	
	ОбработчикиСобытия = ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииИсключенийПоискаСсылок");
	
	Для Каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриДобавленииИсключенийПоискаСсылок(МассивИсключенийИзСобытия);
	КонецЦикла;
	
	МассивИсключенийИзПереопределяемогоМодуля = ОбщегоНазначенияПереопределяемый.ПолучитьИсключенияПоискаСсылок();
	
	ИсключенияПоискаСсылок = Новый Соответствие;
	
	ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключенийИзСобытия);
	ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключенийИзПереопределяемогоМодуля);
	
	Возврат ИсключенияПоискаСсылок;
КонецФункции

// Возвращает значение в виде XML-строки.
// Преобразованы в XML-строку (сериализованы) могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// Значение – Произвольный. Значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
// XML-строка представления значения в сериализованном виде.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает значение, полученное из XML-строки. 
// Получены из XML-строки могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// СтрокаXML – строка представления значения в сериализованном виде.
//
// Возвращаемое значение:
// Значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция WSПрокси(
			Знач АдресWSDL,
			Знач URIПространстваИмен,
			Знач ИмяСервиса,
			Знач ИмяТочкиПодключения = "",
			Знач ИмяПользователя,
			Знач Пароль,
			Знач Таймаут = Неопределено,
			Знач ДелатьКонтрольныйВызов = Ложь
	) Экспорт
	
	Если ДелатьКонтрольныйВызов И Таймаут <> Неопределено И Таймаут > 20 Тогда
		
		WSПроксиPing = ОбщегоНазначенияПовтИсп.WSПрокси(
			АдресWSDL,
			URIПространстваИмен,
			ИмяСервиса,
			ИмяТочкиПодключения,
			ИмяПользователя,
			Пароль,
			3);
		
		Попытка
			WSПроксиPing.Ping();
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'WSПрокси'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение;
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат ОбщегоНазначенияПовтИсп.WSПрокси(
		АдресWSDL,
		URIПространстваИмен,
		ИмяСервиса,
		ИмяТочкиПодключения,
		ИмяПользователя,
		Пароль,
		Таймаут);
	
КонецФункции

// Возвращает общие параметры базовой функциональности.
Функция ОбщиеПараметрыБазовойФункциональности() Экспорт
	
	ОбщиеПараметры = Новый Структура;
	ОбщиеПараметры.Вставить("ИмяФормыПерсональныхНастроек", "");
	ОбщиеПараметры.Вставить("МинимальноНеобходимаяВерсияПлатформы", "8.2.17.153");
	ОбщиеПараметры.Вставить("РаботаВПрограммеЗапрещена", Ложь);
	ОбщиеПараметры.Вставить("ЗапрашиватьПодтверждениеПриЗавершенииПрограммы", Истина);
	
	ОбщегоНазначенияПереопределяемый.ПриОпределенииОбщихПараметровБазовойФункциональности(ОбщиеПараметры);
	
	ОбщегоНазначенияПереопределяемый.ИмяФормыПерсональныхНастроек(ОбщиеПараметры.ИмяФормыПерсональныхНастроек);
	ОбщегоНазначенияВызовСервераПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы(ОбщиеПараметры);
	ОбщегоНазначенияПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы(ОбщиеПараметры);
	
	Возврат ОбщиеПараметры;
	
КонецФункции

// Определяет, что эта информационная база является подчиненным узлом
// распределенной информационной базы (РИБ).
//
Функция ЭтоПодчиненныйУзелРИБ() Экспорт
	
	Возврат ПланыОбмена.ГлавныйУзел() <> Неопределено;
	
КонецФункции

// Возвращает Истина при необходимости обновления конфигурации информационной базы подчиненного узла РИБ.
// В главном узле всегда - Ложь.
//
Функция ТребуетсяОбновлениеКонфигурацииПодчиненногоУзлаРИБ() Экспорт
	
	Возврат ЭтоПодчиненныйУзелРИБ() И КонфигурацияИзменена();
	
КонецФункции

// Выполняет проверки перед запуском переданной формы.
//
Функция ПриСозданииНаСервере(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
		И Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Отказ = Истина;
		Возврат Ложь;
	КонецЕсли;
	
	Если Форма.Параметры.Свойство("АвтоТест")  И ПравоДоступа("Администрирование", Метаданные) Тогда
		// Возврат при получении формы для анализа.
		Возврат Ложь;
	КонецЕсли;
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.ОбновлениеВерсииИБ") Тогда
		
		МодульОбновлениеИнформационнойБазы = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("ОбновлениеИнформационнойБазы");
		Если МодульОбновлениеИнформационнойБазы.ВыполняетсяОбновлениеИнформационнойБазы() Тогда
			Отказ = Истина;
			Возврат Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Возвращает имя базового типа по переданному значению объекта метаданных
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПеречисления();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
		
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаКонстанты();
		
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЖурналыДокументов();
		
	ИначеЕсли Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПоследовательности();
		
	ИначеЕсли Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегламентныеЗадания();
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по полному имени объекта метаданных
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации"
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() = 2 Тогда
		КлассОМ = ЧастиИмени[0];
		ИмяОМ  = ЧастиИмени[1];
	КонецЕсли;
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Если ЧастиИмени.Количество() = 2 Тогда
			// Регистр расчета
			Менеджер = РегистрыРасчета;
		Иначе
			КлассПодчиненногоОМ = ЧастиИмени[2];
			ИмяПодчиненногоОМ = ЧастиИмени[3];
			Если ВРег(КлассПодчиненногоОМ) = "ПЕРЕРАСЧЕТ" Тогда
				// Перерасчет
				Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
			Иначе
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Неизвестный тип объекта метаданных ""%1""'"), ПолноеИмя);
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Менеджер = Константы;
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Попытка
			Возврат Менеджер[ИмяОМ];
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Неизвестный тип объекта метаданных ""%1""'"), ПолноеИмя);
	
КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//  Истина - ссылка физически существует;
//  Ложь   - ссылка физически не существует
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка КАК Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Функция возвращает имя вида объектов метаданных по типу объекта.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Тип       - Тип прикладного объекта, определенный в конфигурации
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоТипу(Тип) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Справочник";
	
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Документ";
	
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцесс";
	
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристик";
	
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетов";
	
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчета";
	
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Задача";
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбмена";
	
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Перечисление";
	
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
	
	КонецЕсли;
	
КонецФункции 

// Возвращает полное имя объекта метаданных по переданному значению ссылки
// Например,
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная"
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного значения ссылки
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

// Проверка того, что тип имеет ссылочный тип данных
//
Функция ЭтоСсылка(Тип) Экспорт
	
	Возврат Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);
	
КонецФункции

// Только для использования в процедуре ОбщегоНазначенияПереопределяемый.Заполнить-
// ТаблицуПереименованияОбъектовМетаданных() для описания переименований объектов метаданных.
// 
// Параметры:
//   Итог                    - передается в процедуру подсистемой БазоваяФункциональность.
//   ВерсияИБ                - Строка - версия при переходе на которую нужно выполнить переименование.
//   СтароеПолноеИмя         - Строка - старое полное имя объекта метаданных,    которое нужно переименовать.
//   НовоеПолноеИмя          - Строка - новое  полное имя объекта метаданных, на которое нужно переименовать.
//   ИдентификаторБиблиотеки - Строка - внутренний идентификатор библиотеки, к которой относится ВерсияИБ,
//                             для основной конфигурации не требуется.
// 
Процедура ДобавитьПереименование(Итог, ВерсияИБ, СтароеПолноеИмя, НовоеПолноеИмя, ИдентификаторБиблиотеки = "") Экспорт
	
	СтароеИмяКоллекции = ВРег(ИмяКоллекции(СтароеПолноеИмя));
	НовоеИмяКоллекции  = ВРег(ИмяКоллекции(НовоеПолноеИмя));
	
	ЗаголовокОшибки =
		НСтр("ru = 'Ошибка в процедуре ЗаполнитьТаблицуПереименованияОбъектовМетаданных
		           |общего модуля ОбщегоНазначенияПереопределяемый.'");
	
	Если СтароеИмяКоллекции <> НовоеИмяКоллекции Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ЗаголовокОшибки + Символы.ПС + Символы.ПС
			+ НСтр("ru = 'Не совпадают имена типов старого объекта метаданных:
			             |""%1""
			             |и нового объекта метаданных:
			             |""%2"".'"),
			СтароеПолноеИмя,
			НовоеПолноеИмя);
	КонецЕсли;
	
	Если Итог.КоллекцииБезКлюча[СтароеИмяКоллекции] = Неопределено Тогда
		
		СписокДопустимыхТипов = "";
		Для каждого КлючИЗначение Из Итог.КоллекцииБезКлюча Цикл
			СписокДопустимыхТипов = СписокДопустимыхТипов + КлючИЗначение.Значение + "," + Символы.ПС;
		КонецЦикла;
		СписокДопустимыхТипов = СокрП(СписокДопустимыхТипов);
		СписокДопустимыхТипов = ?(ЗначениеЗаполнено(СписокДопустимыхТипов),
			Лев(СписокДопустимыхТипов, СтрДлина(СписокДопустимыхТипов) - 1), "");
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ЗаголовокОшибки + Символы.ПС + Символы.ПС
			+ НСтр("ru = 'Объект метаданных ""%1"" и остальные
			             |объекты метаданных этого типа обновляются автоматически.
			             |
			             |Переименование требуется только для следующих типов:
			             |%2.'"),
			СтароеПолноеИмя,
			НовоеПолноеИмя,
			СписокДопустимыхТипов);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИдентификаторБиблиотеки) Тогда
		Библиотека = ВРег(ИдентификаторБиблиотеки) <> ВРег(Метаданные.Имя);
	Иначе
		ИдентификаторБиблиотеки = Метаданные.Имя;
		Библиотека = Ложь;
	КонецЕсли;
	
	ПорядокБиблиотеки = Итог.ПорядокБиблиотек[ИдентификаторБиблиотеки];
	Если ПорядокБиблиотеки = Неопределено Тогда
		ПорядокБиблиотеки = Итог.ПорядокБиблиотек.Количество();
		Итог.ПорядокБиблиотек.Вставить(ИдентификаторБиблиотеки, ПорядокБиблиотеки);
	КонецЕсли;
	
	ВерсияБиблиотеки = Итог.ВерсииБиблиотек[ИдентификаторБиблиотеки];
	Если ВерсияБиблиотеки = Неопределено Тогда
		ВерсияБиблиотеки = ОбновлениеИнформационнойБазы.ВерсияИБ(ИдентификаторБиблиотеки);
		Итог.ВерсииБиблиотек.Вставить(ИдентификаторБиблиотеки, ВерсияБиблиотеки);
	КонецЕсли;
	
	Если ВерсияБиблиотеки = "0.0.0.0" Тогда
		// При начальном заполнении переименования не требуются.
		Возврат;
	КонецЕсли;
	
	Попытка
		Результат = ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияИБ, ВерсияБиблиотеки);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Если Библиотека Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ЗаголовокОшибки + Символы.ПС + Символы.ПС
				+ НСтр("ru = 'При сравнении указанной версии ""%1""
				             |с текущей версией ""%2""
				             |указанной библиотеки ""%3""
				             |произошла ошибка:
				             |""%4"".'"),
				ВерсияИБ,
				ВерсияБиблиотеки,
				ИдентификаторБиблиотеки,
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ЗаголовокОшибки + Символы.ПС + Символы.ПС
				+ НСтр("ru = 'При сравнении указанной версии ""%1""
				             |с текущей версией конфигурации ""%2""
				             |произошла ошибка:
				             |""%3"".'"),
				ВерсияИБ,
				ВерсияБиблиотеки,
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
		КонецЕсли;
	КонецПопытки;
	
	Если Результат > 0 Тогда
		ЧастиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ВерсияИБ, ".");
		
		ОписаниеПереименования = Итог.Таблица.Добавить();
		ОписаниеПереименования.ПорядокБиблиотеки = ПорядокБиблиотеки;
		ОписаниеПереименования.ВерсияЧасть1      = Число(ЧастиВерсии[0]);
		ОписаниеПереименования.ВерсияЧасть2      = Число(ЧастиВерсии[1]);
		ОписаниеПереименования.ВерсияЧасть3      = Число(ЧастиВерсии[2]);
		ОписаниеПереименования.ВерсияЧасть4      = Число(ЧастиВерсии[3]);
		ОписаниеПереименования.СтароеПолноеИмя   = СтароеПолноеИмя;
		ОписаниеПереименования.НовоеПолноеИмя    = НовоеПолноеИмя;
		ОписаниеПереименования.ПорядокДобавления = Итог.Таблица.Индекс(ОписаниеПереименования);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов
//
// Параметры:
//  СтандартныеРеквизиты – ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных стандартных реквизитов;
//  ИмяРеквизита – Строка – реквизит который необходимо проверить на принадлежность множеству стандартных реквизитов;
// 
//  Возвращаемое значение:
// Тип: Булево. Истина -  реквизит входит в подмножество стандартных реквизитов; Ложь – нет.
//
Функция ЭтоСтандартныйРеквизит(СтандартныеРеквизиты, ИмяРеквизита) Экспорт
	
	Для Каждого Реквизит ИЗ СтандартныеРеквизиты Цикл
		Если Реквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// Возвращает признак того, что объект метаданных используется в общих реквизитах-разделителях.
//
// Параметры:
// ОбъектМетаданных - Строка; ОбъектМетаданных - Если объект метаданных задан строкой, происходит обращение к модулю повторного использования.
// Разделитель - имя общего реквизита-разделителя, на разделение которыми проверяется объект метаданных.
//
// Возвращаемое значение:
// Булево - Истина, если объект метаданных используется хотя бы в одном общем разделителе.
//
Функция ЭтоРазделенныйОбъектМетаданных(Знач ОбъектМетаданных, Знач Разделитель) Экспорт
	
	Если ТипЗнч(ОбъектМетаданных) = Тип("Строка") Тогда
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных;
	Иначе
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	КонецЕсли;
	
	РазделенныеОбъектыМетаданных = ОбщегоНазначенияПовтИсп.РазделенныеОбъектыМетаданных(Разделитель);
	Возврат РазделенныеОбъектыМетаданных.Получить(ПолноеИмяОбъектаМетаданных) <> Неопределено;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаДокументы();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаСправочники();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПеречисление(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПеречисления();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланОбмена(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыОбмена();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланВидовХарактеристик(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовХарактеристик();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоБизнесПроцесс(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаБизнесПроцессы();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоЗадача(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЗадачи();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланСчетов(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыСчетов();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПланВидовРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПланыВидовРасчета();
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрСведений(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыСведений();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрНакопления(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыНакопления();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрБухгалтерии(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыБухгалтерии();
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистрРасчета(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегистрыРасчета();
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоКонстанта(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаКонстанты();
	
КонецФункции

// Журналы документов

// Определяет принадлежность объекта метаданных к общему типу "Журнал документов"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоЖурналДокументов(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаЖурналыДокументов();
	
КонецФункции

// Последовательности

// Определяет принадлежность объекта метаданных к общему типу "Последовательности"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоПоследовательность(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаПоследовательности();
	
КонецФункции

// РегламентныеЗадания

// Определяет принадлежность объекта метаданных к общему типу "Регламентные задания"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегламентноеЗадание(ОбъектМетаданных) Экспорт
	
	Возврат ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) = ИмяТипаРегламентныеЗадания();
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоРегистр(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаРегистрыСведений()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыНакопления()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыБухгалтерии()
		ИЛИ ИмяБазовогоТипа = ИмяТипаРегистрыРасчета();
	
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Возврат ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаДокументы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаБизнесПроцессы()
		ИЛИ ИмяБазовогоТипа = ИмяТипаЗадачи()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Возвращает значение для идентификации общего типа "Регистры сведений"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры накопления"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры бухгалтерии"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры расчета"
//
// Тип: Строка
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Документы"
//
// Тип: Строка
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Справочники"
//
// Тип: Строка
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перечисления"
//
// Тип: Строка
//
Функция ИмяТипаПеречисления() Экспорт
	
	Возврат "Перечисления";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Отчеты"
//
// Тип: Строка
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Функция-свойство: возвращает значение для идентификации общего типа "Обработки"
//
// Тип: Строка
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Возвращает значение для идентификации общего типа "ПланыОбмена"
//
// Тип: Строка
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов характеристик"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Бизнес-процессы"
//
// Тип: Строка
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Задачи"
//
// Тип: Строка
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы счетов"
//
// Тип: Строка
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов расчета"
//
// Тип: Строка
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Константы"
//
// Тип: Строка
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов"
//
// Тип: Строка
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Последовательности"
//
// Тип: Строка
//
Функция ИмяТипаПоследовательности() Экспорт
	
	Возврат "Последовательности";
	
КонецФункции

// Возвращает значение для идентификации общего типа "РегламентныеЗадания"
//
// Тип: Строка
//
Функция ИмяТипаРегламентныеЗадания() Экспорт
	
	Возврат "РегламентныеЗадания";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Сохранение, чтение и удаление настроек из хранилищ

// Сохраняет настройку в хранилище общих настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Значение,
		ОписаниеНастроек,
		ИмяПользователя,
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища общих настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур. 
// Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур,
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, Элемент.Настройка, Элемент.Значение);
	КонецЦикла;
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур и обновляет повторно
//   используемые значения. Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//
Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
	
	ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище общих настроек и обновляет повторно используемые 
//   значения.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(КлючОбъекта, КлючНастроек, Значение) Экспорт
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
// 
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища системных настроек.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм.
// 
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить()
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек = "", Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеСистемныхНастроек.Загрузить,
//   подробнее - см. параметры функции ХранилищеЗагрузить()
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек = "", ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища настроек данных форм.
//
// Параметры:
//   Соответствуют методу ХранилищеНастроекДанныхФорм.Удалить,
//   подробнее - см. параметры функции ХранилищеУдалить()
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек через его менеджер.
// 
// Параметры:
//   МенеджерХранилища (СтандартноеХранилищеНастроекМенеджер) Хранилище, в котором сохраняется настройка
//   КлючОбъекта       (Строка) Ключ объекта настройки. 
//                              Подробнее см. раздел справки "Настройки, автоматически сохраняемые в системном хранилище".
//   КлючНастроек      (Строка) Ключ сохраняемых настроек.
//   Значение          (*)      Содержит настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  (ОписаниеНастроек) Содержит информацию об описании настройки.
//   ИмяПользователя   (Строка) Имя пользователя, настройки которого сохраняются.
//                              Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения (Булево)
// 
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения)
	
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек, Значение, ОписаниеНастроек, ИмяПользователя);
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Загружает настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища   (СтандартноеХранилищеНастроекМенеджер) Хранилище, из которого загружается настройка
//   КлючОбъекта         (Строка) Ключ объекта настройки. 
//                                Подробнее см. раздел справки "Настройки, автоматически сохраняемые в системном хранилище".
//   КлючНастроек        (Строка) Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию (*)      Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек    (ОписаниеНастроек) Через данный параметр при загрузке можно получить описание настроек.
//   ИмяПользователя     (Строка) Имя пользователя, настройки которого загружается.
//                                Если не указано, то загружается настройки текущего пользователя.
// 
// Возвращаемое значение: 
//   (*) Настройки, загруженные из хранилища. Неопределено, если настройки не найдены. 
// 
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
	ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
	
	Если (Результат = Неопределено) И (ЗначениеПоУмолчанию <> Неопределено) Тогда
		Результат = ЗначениеПоУмолчанию;
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

// Удаляет настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища (СтандартноеХранилищеНастроекМенеджер) Хранилище, из которого удаляется настройка
//   КлючОбъекта       (Строка)       Ключ объекта настройки. 
//                     (Неопределено) Удаляются настройки для всех объектов.
//   КлючНастроек      (Строка)       Ключ сохраняемых настроек.
//                     (Неопределено) Удаляются настройки со всеми ключами.
//   ИмяПользователя   (Строка)       Имя пользователя, настройки которого загружается.
//                     (Неопределено) Удаляются настройки всех пользователей.
// 
// Возвращаемое значение: 
//   (*) Настройки, загруженные из хранилища. Неопределено, если настройки не найдены. 
// 
Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек, ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с журналом регистрации

// Процедура пакетной записи сообщений в журнал регистрации
// 
// Параметры: СобытияДляЖурналаРегистрации - СписокЗначений, клиентская глобальная переменная
// После записи переменная очищается.
Процедура ЗаписатьСобытияВЖурналРегистрации(СобытияДляЖурналаРегистрации) Экспорт
	
	Если ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений") Тогда
		Возврат;
	КонецЕсли;	
	
	Если СобытияДляЖурналаРегистрации.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СообщениеЖурнала Из СобытияДляЖурналаРегистрации Цикл
		ЗначениеСообщения = СообщениеЖурнала.Значение;
		ИмяСобытия = ЗначениеСообщения.ИмяСобытия;
		УровеньСобытия = УровеньСобытияПоПредставлению(ЗначениеСообщения.ПредставлениеУровня);
		ДатаСобытия = ТекущаяДатаСеанса();
		Если ЗначениеСообщения.Свойство("ДатаСобытия") И ЗначениеЗаполнено(ЗначениеСообщения.ДатаСобытия) Тогда
			ДатаСобытия = ЗначениеСообщения.ДатаСобытия;
		КонецЕсли;
		Комментарий = Строка(ДатаСобытия) + " " + ЗначениеСообщения.Комментарий;
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньСобытия,,, Комментарий);
	КонецЦикла;
	СобытияДляЖурналаРегистрации.Очистить();
	
КонецПроцедуры

// Включить запись уровней событий СписокУровней в журнале регистрации.
//
// Параметры: УровниСобытий - СписокЗначений - наименования уровней регистрации событий, 
//                                             которые необходимо включить
//
Процедура ВключитьИспользованиеЖурналаРегистрации(СписокУровней = Неопределено) Экспорт
	
	МассивУровней = Новый Массив();
	Если СписокУровней = Неопределено Тогда
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Информация);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Ошибка);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Предупреждение);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Примечание);
	Иначе
		МассивУровней = УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней);
	КонецЕсли;
		
	МонопольныйРежимУстановленРанее = МонопольныйРежим();
	УстановитьМонопольныйРежим(Истина);
	
	Попытка
		УстановитьИспользованиеЖурналаРегистрации(МассивУровней);
	Исключение
		Если Не МонопольныйРежимУстановленРанее Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Проверяет, включена ли регистрация событий УровниСобытий в журнале регистрации.
//
// Параметры: 
//   УровниСобытий - СписокЗначений - список строк с уровнями регистрации событий журнала регистрации, 
//                                    для которых необходимо проверить, что они включены.
//                                    Если Неопределено, то проверяются все уровни событий.
//
// Возвращаемое значение: 
//   Булево - Истина, когда заданные режимы включены. Иначе - Ложь.
//
Функция ПроверитьВключениеЖурналаРегистрации(УровниСобытий = Неопределено) Экспорт	
	
	УстановленныеУровниСобытий = ПолучитьИспользованиеЖурналаРегистрации();
	Если УровниСобытий = Неопределено Тогда
		Возврат УстановленныеУровниСобытий.Количество() = 4; // включены все уровни событий?
	КонецЕсли;
	
	ИменаУровнейСобытий = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(УровниСобытий);
	Для Каждого Название Из ИменаУровнейСобытий Цикл
		УровеньСобытия = УровеньСобытияПоПредставлению(Название);
		Если УстановленныеУровниСобытий.Найти(УровеньСобытия) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы в режиме разделения данных

// Устанавливает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе
// начинает транзакцию и устанавливает исключительную управляемую блокировку
// на пространства блокировок всех объектов метаданных, входящих в состав разделителя ОбластьДанных.
//
// В других случаях (например, в локальном режиме работы) устанавливает монопольный режим. 
//
// Параметры:
// ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
// пользовательских сеансов со значением разделителя равным текущему.
// В случае обнаружения других сеансов будет выдано исключение.
// Параметр используется только при работе в модели сервиса.
//
Процедура ЗаблокироватьИБ(Знач ПроверитьОтсутствиеДругихСеансов = Истина) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если НЕ МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Истина);
		КонецЕсли;
	Иначе
		Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			Если НЕ СтандартныеПодсистемыПовтИсп.ЭтоПлатформа83БезРежимаСовместимости() Тогда
				НачатьТранзакцию();
			КонецЕсли;
			МодульРаботаВМоделиСервиса = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
			МодульРаботаВМоделиСервиса.ЗаблокироватьТекущуюОбластьДанных(ПроверитьОтсутствиеДругихСеансов);
		Иначе
			ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
		
КонецПроцедуры

// Снимает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе,
// - если вызов делается внутри обработчика исключения (из секции Исключении...)
//   отменяет транзакцию;
// - иначе фиксирует транзакцию.
//
// В других случаях (например, в локальном режиме работы) снимает монопольный режим. 
//
Процедура РазблокироватьИБ() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
	Иначе
		Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			МодульРаботаВМоделиСервиса = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
			МодульРаботаВМоделиСервиса.РазблокироватьТекущуюОбластьДанных();
			
			Если НЕ СтандартныеПодсистемыПовтИсп.ЭтоПлатформа83БезРежимаСовместимости() Тогда
				Попытка
					ЗафиксироватьТранзакцию();
				Исключение
					ОтменитьТранзакцию();
				КонецПопытки;
			КонецЕсли;
		Иначе
			ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура УстановитьРазделениеСеанса(Знач Использование, Знач ОбластьДанных = Неопределено) Экспорт
	ПриУстановкеРазделенияСеанса(Использование, ОбластьДанных);
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Возвращаемое значение: 
// Тип значения разделителя.
// Значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		ЗначениеРазделителя = Неопределено;
		ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя);
		Возврат ЗначениеРазделителя;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
// Булево - Истина разделение используется, иначе нет.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	ИспользованиеРазделителя = Неопределено;
	ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя);
	Возврат ИспользованиеРазделителя;
	
КонецФункции

// Возвращает обработчики указанного серверного служебного события.
//
// Параметры:
//  Событие  - Строка, например,
//             "СтандартныеПодсистемы.БазоваяФункциональность\ПриОпределенииПоддерживаемыхВерсийПрограммныхИнтерфейсов".
//
// Возвращаемое значение:
//  ФиксированныйМассив со значениями типа
//    ФиксированнаяСтруктура со свойствами:
//      Версия - Строка      - версия обработчика, например, "2.1.3.4". Пустая строка, если не указана.
//      Модуль - ОбщийМодуль - серверный общий модуль.
// 
Функция ОбработчикиСлужебногоСобытия(Событие) Экспорт
	
	Массив = Новый Массив;
	
	Обработчики = СтандартныеПодсистемыПовтИсп.ОбработчикиСерверногоСобытия(Событие, Истина);
	Для каждого Обработчик Из Обработчики Цикл
		
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль(Обработчик.Модуль);
		
		Элемент = Новый Структура;
		Элемент.Вставить("Модуль",     Модуль);
		Элемент.Вставить("ИмяМодуля",  Обработчик.Модуль);
		Элемент.Вставить("Версия",     Обработчик.Версия);
		Элемент.Вставить("Подсистема", Обработчик.Подсистема);
		
		Массив.Добавить(Новый ФиксированнаяСтруктура(Элемент));
	КонецЦикла;
	
	Возврат Новый ФиксированныйМассив(Массив);
	
КонецФункции

// Обновляет данные в кэше версий
//
// Параметры:
//  Идентификатор - Строка - идентификатор записи кэша
//  ТипДанных - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - 
//   тип обновляемых данных
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш
//
Процедура ОбновитьДанныеКэшаВерсий(Знач Идентификатор, Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТаблицаКэша.ДатаОбновления КАК ДатаОбновления,
		|	ТаблицаКэша.Данные КАК Данные,
		|	ТаблицаКэша.ТипДанных КАК ТипДанных
		|ИЗ
		|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
		|ГДЕ
		|	ТаблицаКэша.Идентификатор = &Идентификатор
		|	И ТаблицаКэша.ТипДанных = &ТипДанных";
	Идентификатор = Идентификатор;
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	Запрос.УстановитьПараметр("ТипДанных", ТипДанных);
	
	НачатьТранзакцию();
	
	ОшибкаУстановкиБлокировки = Ложь;
	
	Попытка
		
		СтруктураКлюча = Новый Структура("Идентификатор, ТипДанных", Идентификатор, ТипДанных);
		Ключ = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьКлючЗаписи(СтруктураКлюча);
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
		Исключение
			// Данные уже обновляются из другого сеанса
			ОшибкаУстановкиБлокировки = Истина;
			ВызватьИсключение;
		КонецПопытки;
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ЭлементБлокировки.УстановитьЗначение("Идентификатор", Идентификатор);
		ЭлементБлокировки.УстановитьЗначение("ТипДанных", ТипДанных);
		Блокировка.Заблокировать();
		
		Результат = Запрос.Выполнить();
		
		// Убедимся что данные требуют обновления
		Если НЕ Результат.Пустой() Тогда
			Выборка = Результат.Выбрать();
			Выборка.Следующий();
			Если НЕ ЗаписьКэшаВерсийУстарела(Выборка) Тогда
				// Данные актуальны
				ОтменитьТранзакцию();
				Возврат;
			КонецЕсли;
		КонецЕсли;
		
		Набор = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьНаборЗаписей();
		
		Набор.Отбор.Идентификатор.Установить(Идентификатор);
		Набор.Отбор.ТипДанных.Установить(ТипДанных);
		
		Запись = Набор.Добавить();
		Запись.Идентификатор = Идентификатор;
		Запись.ТипДанных = ТипДанных;
		Запись.ДатаОбновления = ТекущаяУниверсальнаяДата();
		
		Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено() Или Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
			Данные = ПодготовитьДанныеКэшаВерсий(ТипДанных, ПараметрыПолучения);
			Запись.Данные = Новый ХранилищеЗначения(Данные);
			
		Иначе
			
			Набор.ДополнительныеСвойства.Вставить("ПараметрыПолучения", ПараметрыПолучения);
			
		КонецЕсли;
		
		Набор.Записать();
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		
		Если ОшибкаУстановкиБлокировки Тогда
			Возврат;
		Иначе
			ВызватьИсключение;
		КонецЕсли;
		
	КонецПопытки;
	
КонецПроцедуры

// Подготавливает данные для кэша программных интерфейсов.
//
// Параметры:
//  ТипДанных - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - 
//   тип обновляемых данных
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш
//
Функция ПодготовитьДанныеКэшаВерсий(Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	Если ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса Тогда
		Данные = ПолучитьВерсииИнтерфейсаВКэш(ПараметрыПолучения[0], ПараметрыПолучения[1]);
	ИначеЕсли ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Данные = ПолучитьWSDL(ПараметрыПолучения[0], ПараметрыПолучения[1], ПараметрыПолучения[2], ПараметрыПолучения[3]);
	Иначе
		ШаблонТекста = НСтр("ru = 'Неизвестный тип данных кэша версий: %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонТекста, ТипДанных);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Возвращает факт устаревания записи кэша версий
//
// Параметры:
//  Запись - РегистрСведенийМенеджерЗаписи.КэшПрограммныхИнтерфейсов - запись
//   факт устаревания которой требуется проверить
//
// Возвращаемое значение:
//  Булево - признак устаревания записи
//
Функция ЗаписьКэшаВерсийУстарела(Знач Запись) Экспорт
	
	Если Запись.ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Возврат НЕ ЗначениеЗаполнено(Запись.ДатаОбновления)
	Иначе
		Возврат Запись.ДатаОбновления + 86400 < ТекущаяУниверсальнаяДата();
	КонецЕсли;
	
КонецФункции

// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на получение wsdl
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений 
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
Функция WSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль, Знач Таймаут = 10) Экспорт
	
	ДоступноПолучениеФайловИзИнтернета = Неопределено;
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		ДоступноПолучениеФайловИзИнтернета = Истина;
	КонецЕсли;
	
	Если ДоступноПолучениеФайловИзИнтернета = Истина Тогда
	
		ПараметрыПолучения = Новый Массив;
		ПараметрыПолучения.Добавить(АдресWSDL);
		ПараметрыПолучения.Добавить(ИмяПользователя);
		ПараметрыПолучения.Добавить(Пароль);
		ПараметрыПолучения.Добавить(Таймаут);
		
		ДанныеWSDL = ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
			АдресWSDL, 
			Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса, 
			ЗначениеВСтрокуXML(ПараметрыПолучения),
			Ложь);
			
		ИмяФайлаWSDL = ПолучитьИмяВременногоФайла("wsdl");
		
		ДанныеWSDL.Записать(ИмяФайлаWSDL);
		
		Определения = Новый WSОпределения(ИмяФайлаWSDL);
		
		Попытка
			УдалитьФайлы(ИмяФайлаWSDL);
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Возврат Определения;
		
	Иначе
		
		Параметры = Новый Массив;
		Параметры.Добавить(АдресWSDL);
		Параметры.Добавить(ИмяПользователя);
		Параметры.Добавить(Пароль);
		Параметры.Добавить(Таймаут);
		
		Возврат Новый(Тип("WSОпределения"), Параметры);
		
	КонецЕсли;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса
//  ИмяСервиса - Строка - имя сервиса
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap
//  ИмяПользователя - Строка - имя пользователя для входа на сервер
//  Пароль - Строка - пароль пользователя
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси 
//
// Возвращаемое значение:
//  WSПрокси
//
Функция ВнутренняяWSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "", Знач ИмяПользователя, Знач Пароль,
	Знач Таймаут = Неопределено) Экспорт
	
	WSОпределения = ОбщегоНазначенияПовтИсп.WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
	Если ПустаяСтрока(ИмяТочкиПодключения) Тогда
		ИмяТочкиПодключения = ИмяСервиса + "Soap";
	КонецЕсли;
	
	Параметры = Новый Массив;
	Параметры.Добавить(WSОпределения);
	Параметры.Добавить(URIПространстваИмен);
	Параметры.Добавить(ИмяСервиса);
	Параметры.Добавить(ИмяТочкиПодключения);
	Параметры.Добавить(Таймаут);
	
	Прокси = Новый(Тип("WSПрокси"), Параметры);
	Прокси.Пользователь = ИмяПользователя;
	Прокси.Пароль = Пароль;
	
	Возврат Прокси;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Устаревшие процедуры и функции

// Устарела. Следует использовать ПриСозданииНаСервере.
Функция ПриСозданииФормыНаСервере(Форма, СтандартнаяОбработка, Отказ) Экспорт
	
	Возврат Не ПриСозданииНаСервере(Форма, Отказ, СтандартнаяОбработка);
	
КонецФункции

// Устарела. Следует использовать ЗначенияРеквизитовОбъекта.
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт

	Возврат ЗначенияРеквизитовОбъекта(Ссылка, ИменаРеквизитов);
	
КонецФункции

// Устарела. Следует использовать ЗначениеРеквизитаОбъекта.
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита);
	
КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция УровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции

Функция УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней)
	МассивНазванийУровней = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокУровней);
	МассивУровней = Новый Массив;
	Для Каждого Название Из МассивНазванийУровней Цикл
		МассивУровней.Добавить(УровеньСобытияПоПредставлению(Название));
	КонецЦикла;
	Возврат МассивУровней;
КонецФункции

Функция ПолучитьВерсииИнтерфейсаВКэш(Знач ПараметрыПодключения, Знач ИмяИнтерфейса)
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		
		Если ПараметрыПодключения.Свойство("Password") Тогда
			ПарольПользователя = ПараметрыПодключения.Password;
		Иначе
			ПарольПользователя = Неопределено;
		КонецЕсли;
		
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + "/ws/InterfaceVersion?wsdl";
	
	ПроксиВерсионирования = WSПрокси(АдресСервиса, "http://www.1c.ru/SaaS/1.0/WS",
		"InterfaceVersion", , ИмяПользователя, ПарольПользователя, 3);
		
	МассивXDTO = ПроксиВерсионирования.GetVersions(ИмяИнтерфейса);
	Если МассивXDTO = Неопределено Тогда
		Возврат Новый ФиксированныйМассив(Новый Массив);
	Иначе	
		Сериализатор = Новый СериализаторXDTO(ПроксиВерсионирования.ФабрикаXDTO);
		Возврат Новый ФиксированныйМассив(Сериализатор.ПрочитатьXDTO(МассивXDTO));
	КонецЕсли;
	
КонецФункции

Функция ПолучитьWSDL(Знач Адрес, Знач ИмяПользователя, Знач Пароль, Знач Таймаут)
	
	ПараметрыПолучения = Новый Структура;
	Если НЕ ПустаяСтрока(ИмяПользователя) Тогда
		ПараметрыПолучения.Вставить("Пользователь", ИмяПользователя);
		ПараметрыПолучения.Вставить("Пароль", Пароль);
	КонецЕсли;
	ПараметрыПолучения.Вставить("Таймаут", Таймаут);
	
	ОписаниеФайла = Неопределено;
	
	ПриСкачиванииФайлаНаСервере(Адрес, ПараметрыПолучения, ОписаниеФайла);
	
	Если НЕ ОписаниеФайла.Статус Тогда
		ВызватьИсключение(НСтр("ru = 'Ошибка получения файла описания web-сервиса:'") + Символы.ПС + ОписаниеФайла.СообщениеОбОшибке)
	КонецЕсли;
	
	// Попробуем создать WS определения на основе полученного файла
	Определения = Новый WSОпределения(ОписаниеФайла.Путь);
	Если Определения.Сервисы.Количество() = 0 Тогда
		ШаблонСообщения = НСтр("ru = 'Ошибка получения файла описания web-сервиса:
			|В полученном файле не содержится ни одного описания сервиса.
			|
			|Возможно, адрес файла описания указан неверно:
			|%1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Адрес);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	Определения = Неопределено;
	
	ДанныеФайла = Новый ДвоичныеДанные(ОписаниеФайла.Путь);
	
	Попытка
		УдалитьФайлы(ОписаниеФайла.Путь);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат ДанныеФайла;
	
КонецФункции

Функция ИмяКоллекции(ПолноеИмя)
	
	ПозицияТочки = Найти(ПолноеИмя, ".");
	
	Если ПозицияТочки > 0 Тогда
		Возврат Лев(ПолноеИмя, ПозицияТочки - 1);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

Процедура ПроверкаФиксированностиДанных(Данные, ДанныеВЗначенииФиксированныхТипов = Ложь)
	
	ТипДанных = ТипЗнч(Данные);
	
	Если ТипДанных = Тип("ХранилищеЗначения")
	 ИЛИ ТипДанных = Тип("ФиксированныйМассив")
	 ИЛИ ТипДанных = Тип("ФиксированнаяСтруктура")
	 ИЛИ ТипДанных = Тип("ФиксированноеСоответствие") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ДанныеВЗначенииФиксированныхТипов Тогда
		
		Если ТипДанных = Тип("Булево")
		 ИЛИ ТипДанных = Тип("Строка")
		 ИЛИ ТипДанных = Тип("Число")
		 ИЛИ ТипДанных = Тип("Дата")
		 ИЛИ ТипДанных = Тип("Неопределено")
		 ИЛИ ТипДанных = Тип("УникальныйИдентификатор")
		 ИЛИ ТипДанных = Тип("Null")
		 ИЛИ ТипДанных = Тип("Тип")
		 ИЛИ ТипДанных = Тип("ХранилищеЗначения")
		 ИЛИ ТипДанных = Тип("ОбщийМодуль")
		 ИЛИ ТипДанных = Тип("ОбъектМетаданных")
		 ИЛИ ТипДанных = Тип("ТипЗначенияXDTO")
		 ИЛИ ТипДанных = Тип("ТипОбъектаXDTO")
		 ИЛИ ЭтоСсылка(ТипДанных) Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка в функции ФиксированныеДанные общего модуля ОбщегоНазначения.
		           |Данные типа ""%1"" не могут быть зафиксированы.'"),
		Строка(ТипДанных) );
	
КонецПроцедуры

Процедура ДобавитьИсключенияПоискаСсылок(ИсключенияПоискаСсылок, МассивИсключений)
	Для Каждого ЭлементМассива Из МассивИсключений Цикл
		Если ТипЗнч(ЭлементМассива) = Тип("Строка") Тогда
			ЭлементМетаданные = Метаданные.НайтиПоПолномуИмени(ЭлементМассива);
		Иначе
			ЭлементМетаданные = ЭлементМассива;
		КонецЕсли;
		
		РодительМетаданные = ЭлементМетаданные.Родитель();
		
		// Регистрация исключаемого объекта метаданных целиком (всех ссылок, которые он может содержать).
		Если ТипЗнч(РодительМетаданные) = Тип("ОбъектМетаданныхКонфигурация") Тогда
			ИсключенияПоискаСсылок.Вставить(ЭлементМетаданные, "*");
			Продолжить;
		КонецЕсли;
		
		// Регистрация исключаемого реквизита объекта метаданных.
		ОтносительныйПутьКРеквизиту = ЭлементМетаданные.Имя;
		РодительРодителя = РодительМетаданные.Родитель();
		Пока ТипЗнч(РодительРодителя) <> Тип("ОбъектМетаданныхКонфигурация") Цикл
			ОтносительныйПутьКРеквизиту = РодительМетаданные.Имя + "." + ОтносительныйПутьКРеквизиту;
			РодительМетаданные = РодительРодителя;
			РодительРодителя   = РодительМетаданные.Родитель();
		КонецЦикла;
		
		ПутиКРеквизитам = ИсключенияПоискаСсылок.Получить(РодительМетаданные);
		Если ПутиКРеквизитам = Неопределено Тогда
			ПутиКРеквизитам = Новый Массив;
		ИначеЕсли ПутиКРеквизитам = "*" Тогда
			Продолжить; // - Пропуск, если весь объект метаданных уже исключен.
		КонецЕсли;
		ПутиКРеквизитам.Добавить(ОтносительныйПутьКРеквизиту);
		
		ИсключенияПоискаСсылок.Вставить(РодительМетаданные, ПутиКРеквизитам);
	КонецЦикла;
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы

// Получить файл из Интернета по протоколу http(s), либо ftp и сохранить его во временный файл.
//
// Параметры:
//   URL                  - Строка - url файла в формате
//                                   [Протокол://]<Сервер>/<Путь к файлу на сервере>
//   ПараметрыПолучения   - Структура со свойствами
//     ПутьДляСохранения    - Строка - путь на сервере (включая имя файла), для сохранения скачанного файла
//     Пользователь         - Строка - пользователь от имени которого установлено соединение
//     Пароль               - Строка - пароль пользователя от которого установлено соединение
//     Порт                 - Число  - порт сервера с которым установлено соединение
//     ЗащищенноеСоединение - Булево - для случая http загрузки флаг указывает,
//                                     что соединение должно производиться через https
//     ПассивноеСоединение  - Булево - для случая ftp загрузки флаг указывает,
//                                     что соединение должно пассивным (или активным)
//   ВозвращаемоеЗначение - (выходной параметр)
//     Структура, со свойствами
//       Статус - Булево - ключ присутствует в структуре всегда, значения
//                         Истина - вызов функции успешно завершен
//                         Ложь   - вызов функции завершен неудачно
//       Путь   - Строка - путь к файлу на сервере, ключ используется только
//                         если статус Истина
//       СообщениеОбОшибке - Строка - сообщение об ошибке, если статус Ложь
//
Процедура ПриСкачиванииФайлаНаСервере(Знач Адрес, Знач ПараметрыПолучения, ВозвращаемоеЗначение)
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернета = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("ПолучениеФайловИзИнтернета");
		ВозвращаемоеЗначение = МодульПолучениеФайловИзИнтернета.СкачатьФайлНаСервере(Адрес, ПараметрыПолучения);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Параметры:
//  ЗначениеРазделителя - Значение разделителя текущей области данных. Возвращаемый параметр.
//
Процедура ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя)
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		ЗначениеРазделителя = МодульРаботаВМоделиСервиса.ЗначениеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Параметры:
// ИспользованиеРазделителя - Булево - Истина разделение используется, иначе нет. Возвращаемый параметр.
// 
Процедура ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		ИспользованиеРазделителя = МодульРаботаВМоделиСервиса.ИспользованиеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений

// Получает имя значения перечисления как объекта метаданных
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: ТаблицаЗначений
//	Возвращаемое значение: Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

// Создает структуру аналогичную менеджеру записи регистра сведений
// 
// Параметры:
//	МенеджерЗаписи - РегистрСведенийМенеджерЗаписи,
//	МетаданныеРегистра - метаданные регистра сведений
//
Функция СтруктураПоМенеджеруЗаписи(МенеджерЗаписи, МетаданныеРегистра) Экспорт
	
	ЗаписьКакСтруктура = Новый Структура;
	
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		ЗаписьКакСтруктура.Вставить("Период", МенеджерЗаписи.Период);
	КонецЕсли;
	Для Каждого Поле Из МетаданныеРегистра.Измерения Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Ресурсы Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Реквизиты Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	
	Возврат ЗаписьКакСтруктура;
	
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции строк
//
// Параметры:
//	КоллекцияСтрок - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИмяКолонки - строка с именем поля коллекции, значения которого нужно выгрузить
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только различающиеся значения 
//
Функция ВыгрузитьКолонку(КоллекцияСтрок, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт

	МассивЗначений = Новый Массив;
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

// Читает из строки XML или ЧтенияXML и возвращает структуру с описанием и данными таблицы значений.
//
//    Параметры:
//        Текст - строка, или ЧтениеXML с данными. 
//
//    Ожидаемый XML:
//        - типовая сериализация таблицы значений ( {http://v8.1c.ru/8.1/data/core}, ValueTable )
//
//        - старый формат: 
//                <Items Description="<Описание>" Columns="<ИмяКолонки1>, <ИмяКолонки2>... <ИмяКолонки3>" >
//                    <Item <ИмяКолонки1>="<Значение1>" <ИмяКолонки2>="<Значение2>" ... />
//                    ...
//                </Items>
//
//        - новый, упрощенный формат: 
//                <ТегКорня <ПервыйАтрибут>="<ОписаниеКолонок" Description="<Описание>">
//                    <ТегСтроки <ИмяКолонки1>="<Значение1>" <ИмяКолонки2>="<Значение2>" ... />
//                    ...
//                </ТегКорня>
//            При этом ТегКорня и ТегСтроки могут быть произвольными, Описание таблицы считывается из необязательного
//        атрибута Description корня, описание колонок - из первого атрибута корня. Описание колонок состоит из 
//        разделенных запятыми данных одиночной колонки. Для одиночной колонки указывается имя, необязательный тип
//        и необязательные квалификаторы. Например, описание колонок может быть таким:
//        "Код (Строка, 3, Фиксированная), Наименование (Строка), Порядок(Число, 10, 0, Неотрицательный), Данные"
//            Подробно описание типов см в функции ОписаниеТипаИзСтроки.
//
Функция ТаблицаЗначенийИзXML(Текст) Экспорт
	
	Если ТипЗнч(Текст)=Тип("ЧтениеXML") Тогда
		Чтение = Текст;
	Иначе
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(Текст);
	КонецЕсли;
	
	// Пытаемся читать как стандартную сериализацию
	ТипДанных = СериализаторXDTO.ПолучитьXMLТип(Чтение);
	Если ТипДанных=СериализаторXDTO.XMLТип(Тип("ТаблицаЗначений")) Тогда
		Возврат Новый Структура("Данные, Описание", СериализаторXDTO.ПрочитатьXML(Чтение) );
	КонецЕсли;
	
	// Разбираем формат вручную (стоим на корневом узле - результат попытки чтения)
	ТипУзла = Чтение.ТипУзла;
	Пока Истина Цикл
		Если ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
			Прервать;
		ИначеЕсли ТипУзла=ТипУзлаXML.Ничего Тогда
			ВызватьИсключение НСтр("ru='Не найден корневой узел XML'");
		КонецЕсли;
		Чтение.Прочитать();
	КонецЦикла;
	
	ИмяКорня = Чтение.Имя;
	
	ИмяАтрибутаОписания = "Description";
	Описание = Чтение.ПолучитьАтрибут(ИмяАтрибутаОписания);
	
	ИменаКолонок = Чтение.ПолучитьАтрибут("Columns");
	Если ИменаКолонок=Неопределено Тогда
		// Читаем из первого подходящего атрибута - не описания
		Пока Чтение.СледующийАтрибут() Цикл
			Если Описание=Неопределено Или Чтение.Имя<>ИмяАтрибутаОписания Тогда
				ИменаКолонок = Чтение.Значение;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Формируем колонки с типом
	ИменаКолонок = СтрЗаменить(СтрЗаменить(ИменаКолонок, " ", "") + ",", "),", Символы.ПС);
	Результат    = Новый ТаблицаЗначений;
	Колонки      = Результат.Колонки;
	
	Для Индекс=1 По СтрЧислоСтрок(ИменаКолонок) Цикл
		СтрокаИмени = СтрПолучитьСтроку(ИменаКолонок, Индекс);
		Поз = Найти(СтрокаИмени, "(");
		Если Поз>0 Тогда 
			// Нашли описание типа
			Результат.Колонки.Добавить(Лев(СтрокаИмени, Поз-1), ОписаниеТипаИзСтроки( Сред(СтрокаИмени, Поз+1) ));
		Иначе
			Для Каждого КлючЗначение Из Новый Структура(СтрокаИмени) Цикл
				Колонки.Добавить(КлючЗначение.Ключ);
			КонецЦикла
		КонецЕсли;
	КонецЦикла;
	
	// Собственно чтение
	Пока Чтение.Прочитать() Цикл
		ТипУзла = Чтение.ТипУзла;
		Если ТипУзла=ТипУзлаXML.КонецЭлемента И Чтение.Имя=ИмяКорня Тогда
			Прервать;
		ИначеЕсли ТипУзла=ТипУзлаXML.НачалоЭлемента Тогда
			СтрокаТаблицы = Результат.Добавить();
			Для Каждого Колонка Из Колонки Цикл
				Имя = Колонка.Имя;
				СтрокаТаблицы[Имя] = Чтение.ПолучитьАтрибут(Имя);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Описание, Данные", Описание, Результат);
КонецФункции

// Возвращает объект ОписаниеТипов, построенный по строке текста
// 
//    Параметры:
//        Текст - строка, описывающая тип. Состоит из обязательного имени типа и необязательных квалификаторов, 
//                разделенных запятыми.
//
//    Для типа "Строка" распознаются необязательные квалификаторы:
//        - максимальная длина (число, по умолчанию 0 - без ограничений)
//        - допустимая длина (строка "Переменная" или "Фиксированная", по умолчанию - переменная)
//
//    Для типа "Число" распознаются необязательные квалификаторы:
//        - число разрядов (число, по умолчанию 0 - без ограничений)
//        - число разрядов дробной части (число, по умолчанию 0)
//        - допустимый знак (строка "Любой" или "Неотрицательный", по умолчанию - любой)
//
//    Для типа "Дата" распознается необязательный квалификатор части даты (строка "Время" или "Дата" или "ДатаВремя",
//    по умолчанию "ДатаВремя")
//
//    Для типа "ДвоичныеДанные" распознаются необязательные квалификаторы:
//        - максимальная длина (число, по умолчанию 0 - без ограничений)
//        - допустимая длина (строка "Переменная" или "Фиксированная", по умолчанию - переменная)
//
//    Для остальных типов обрабатывается только имя типа
//
Функция ОписаниеТипаИзСтроки(Текст) Экспорт
	ЧастиОписания = СтрЗаменить(СтрЗаменить(Текст, Символы.ПС, ""), ",", Символы.ПС);
	КоличествоЧастей = СтрЧислоСтрок(ЧастиОписания);
	
	ИмяИсходногоТипа = СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 1));
	Если КоличествоЧастей=1 Тогда
		Возврат Новый ОписаниеТипов(ИмяИсходногоТипа);
	КонецЕсли;
	
	ИсходныйТип = Тип(ИмяИсходногоТипа);
	Если ИсходныйТип=Тип("Строка") Или ИсходныйТип=Тип("ДвоичныеДанные") Тогда
		МаксимальнаяДлинаСтроки = "0" + СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 2));
		ДопустимаяДлинаСтроки   = СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 3));
		Если ПустаяСтрока(ДопустимаяДлинаСтроки) Тогда
			ДопустимаяДлинаСтроки = "Переменная";
		КонецЕсли;
		Возврат Новый ОписаниеТипов("Строка", Новый КвалификаторыСтроки(
			Число(МаксимальнаяДлинаСтроки), ДопустимаяДлина[ДопустимаяДлинаСтроки]
		));
		
	ИначеЕсли ИсходныйТип=Тип("Число") Тогда
		ДлинаЧисла          = "0" + СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 2));
		ДлинаДробнойЧасти   = "0" + СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 3));
		ДопустимыйЗнакЧисла = СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 4));
		Если ПустаяСтрока(ДопустимыйЗнакЧисла) Тогда
			ДопустимыйЗнакЧисла = "Любой";
		КонецЕсли;
		Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(
			Число(ДлинаЧисла), Число(ДлинаДробнойЧасти), ДопустимыйЗнак[ДопустимыйЗнакЧисла]
		));
			
	ИначеЕсли ИсходныйТип=Тип("Дата") Тогда
		СоставДаты = СокрЛП(СтрПолучитьСтроку(ЧастиОписания, 2));
		Если ПустаяСтрока(СоставДаты) Тогда
			СоставДаты = "ДатаВремя";
		КонецЕсли;
		Возврат Новый ОписаниеТипов("Дата", Новый КвалификаторыДаты( 
			ЧастиДаты[СоставДаты]
		));
		
	КонецЕсли;

	Возврат Новый ОписаниеТипов(ИмяИсходногоТипа);
КонецФункции

// Функция выполняет сравнение двух коллекций строк, для которых доступен обход 
// посредством оператора Для каждого … Из … Цикл.
// Сравниваемые коллекции должны отвечать следующим требованиям:
//	- доступен обход посредством оператора Для каждого … Из … Цикл,
//	- наличие в обеих коллекциях всех колонок, перечисленных в параметре ИменаКолонок 
//  (если ИменаКолонок не заполнен - всех колонок)
//
// Параметры:
//	КоллекцияСтрок1 - коллекция, отвечающая вышеописанным требованиям
//	КоллекцияСтрок2 - коллекция, отвечающая вышеописанным требованиям
//	ИменаКолонок 	- строка, разделенная запятыми - имена колонок, 
//						по которым производится сравнение. 
//						Не является обязательным для коллекций, 
//						состав колонок которых можно выявить: 
//						ТаблицаЗначений, СписокЗначений, Соответствие, Структура,
//						если не указан - сравнение производится по всем колонкам.
//						Для коллекций других типов является обязательным
//	ИсключаяКолонки	- имена колонок, которые игнорируются при сравнении, необязательный
//	УчитыватьПоследовательностьСтрок - булево, если Истина, то коллекции признаются 
//						идентичными только если одинаковые строки размещены 
//						в коллекциях на одинаковых местах
//
Функция КоллекцииИдентичны(КоллекцияСтрок1, КоллекцияСтрок2, ИменаКолонок = "", ИсключаяКолонки = "", УчитыватьПоследовательностьСтрок = Ложь) Экспорт
	
	// Типы коллекций, для которых доступен состав колонок, 
	// и можно выявить, если он не задан
	ТипыОсобыхКоллекций = Новый Массив;
	ТипыОсобыхКоллекций.Добавить(Тип("ТаблицаЗначений"));
	ТипыОсобыхКоллекций.Добавить(Тип("СписокЗначений"));
	
	ТипыКоллекцийКлючИЗначение = Новый Массив;
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Соответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Структура"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированноеСоответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированнаяСтруктура"));
	
	Если ПустаяСтрока(ИменаКолонок) Тогда
		Если ТипыОсобыхКоллекций.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено 
			Или ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
			СравниваемыеКолонки = Новый Массив;
			Если ТипЗнч(КоллекцияСтрок1) = Тип("ТаблицаЗначений") Тогда
				Для Каждого Колонка Из КоллекцияСтрок1.Колонки Цикл
					СравниваемыеКолонки.Добавить(Колонка.Имя);
				КонецЦикла;
			ИначеЕсли ТипЗнч(КоллекцияСтрок1) = Тип("СписокЗначений") Тогда
				СравниваемыеКолонки.Добавить("Значение");
				СравниваемыеКолонки.Добавить("Картинка");
				СравниваемыеКолонки.Добавить("Пометка");
				СравниваемыеКолонки.Добавить("Представление");
			ИначеЕсли ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
				СравниваемыеКолонки.Добавить("Ключ");
				СравниваемыеКолонки.Добавить("Значение");
			КонецЕсли;
		Иначе
			ТекстИсключения = НСтр("ru = 'Для коллекции типа %1 необходимо указать имена полей, по которым производится сравнение'");
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ТипЗнч(КоллекцияСтрок1));
		КонецЕсли;
	Иначе
		СравниваемыеКолонки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаКолонок);
	КонецЕсли;

	// Вычитаем исключаемые поля
	СравниваемыеКолонки = ОбщегоНазначенияКлиентСервер.СократитьМассив(СравниваемыеКолонки, 
						СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяКолонки));
						
	Если УчитыватьПоследовательностьСтрок Тогда
		
		// Параллельный обход обеих коллекций
		НомерСтрокиКоллекции1 = 0;
		Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
			// Спозиционируемся на аналогичную строку второй коллекции
			НомерСтрокиКоллекции2 = 0;
			ЕстьСтрокиКоллекции2 = Ложь;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЕстьСтрокиКоллекции2 = Истина;
				Если НомерСтрокиКоллекции2 = НомерСтрокиКоллекции1 Тогда
					Прервать;
				КонецЕсли;
				НомерСтрокиКоллекции2 = НомерСтрокиКоллекции2 + 1;
			КонецЦикла;
			Если Не ЕстьСтрокиКоллекции2 Тогда
				// Во второй коллекции вообще нет строк
				Возврат Ложь;
			КонецЕсли;
			// Сравниваем значения полей двух строк
			Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
				Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаКоллекции2[ИмяКолонки] Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			НомерСтрокиКоллекции1 = НомерСтрокиКоллекции1 + 1;
		КонецЦикла;
		
		КоличествоСтрокКоллекции1 = НомерСтрокиКоллекции1;
		
		// Отдельно подсчитаем количество строк второй коллекции
		КоличествоСтрокКоллекции2 = 0;
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			КоличествоСтрокКоллекции2 = КоличествоСтрокКоллекции2 + 1;
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если КоличествоСтрокКоллекции1 = 0 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
			КоличествоСтрокКоллекции2 = 0;
		КонецЕсли;
		
		// Количество строк не должно отличаться
		Если КоличествоСтрокКоллекции1 <> КоличествоСтрокКоллекции2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
	
		// Проверяем идентичность состава одинаковых строк без учета их последовательности
		
		// Строки отбора накапливаем по первой коллекции для того, чтобы:
		//  - повторно не искать одинаковые строки,
		//  - убедиться, что во второй коллекции ни одной такой строки, которой нет в накопленных
		
		СтрокиОтбора = Новый ТаблицаЗначений;
		ПараметрыОтбора = Новый Структура;
		Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
			СтрокиОтбора.Колонки.Добавить(ИмяКолонки);
			ПараметрыОтбора.Вставить(ИмяКолонки);
		КонецЦикла;
		
		ЕстьСтрокиКоллекции1 = Ложь;
		Для Каждого СтрокаОтбора Из КоллекцияСтрок1 Цикл
			
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаОтбора);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() > 0 Тогда
				// строку с такими полями уже искали
				Продолжить;
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(СтрокиОтбора.Добавить(), СтрокаОтбора);
			
			// Подсчитаем количество таких строк в первой коллекции
			НайденоСтрокКоллекции1 = 0;
			Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции1 = НайденоСтрокКоллекции1 + 1;
				КонецЕсли;
			КонецЦикла;
			
			// Подсчитаем количество таких строк во второй коллекции
			НайденоСтрокКоллекции2 = 0;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции2[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции2 = НайденоСтрокКоллекции2 + 1;
					// Если количество таких строк во второй коллекции превысило количество в первой, 
					// то уже можно сделать вывод, что коллекции не идентичны
					Если НайденоСтрокКоллекции2 > НайденоСтрокКоллекции1 Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			// Количество таких строк не должно отличаться
			Если НайденоСтрокКоллекции1 <> НайденоСтрокКоллекции2 Тогда
				Возврат Ложь;
			КонецЕсли;
			
			ЕстьСтрокиКоллекции1 = Истина;
			
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если Не ЕстьСтрокиКоллекции1 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
		КонецЕсли;
		
		// Проверим, что во второй коллекции нет ни одной такой строки, которой нет в накопленных
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаКоллекции2);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() = 0 Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Создает копию объекта XDTO.
//
// Параметры:
//  Фабрика - ФабрикаXDTO - фабрика, которой создан исходный объект
//  Объект - ОбъектXDTO - объект, копию которого требуется создать
//
// Возвращаемое значение:
//  ОбъектXDTO - копия исходного объекта XDTO
Функция СкопироватьXDTO(Знач Фабрика, Знач Объект) Экспорт
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, Объект, , , , НазначениеТипаXML.Явное);
	
	XMLПредставление = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(XMLПредставление);
	
	Возврат Фабрика.ПрочитатьXML(Чтение, Объект.Тип());
	
КонецФункции

// Возвращает XML представление типа XDTO.
//
// Параметры:
//  ТипXDTO - ТипОбъектаXDTO, ТипЗначенияXDTO - тип XDTO для которого требуется получить
//   XML представление
//
// Возвращаемое значение:
//  Строка - XML представление типа XDTO
//
Функция ПредставлениеТипаXDTO(ТипXDTO) Экспорт
	
	Возврат СериализаторXDTO.XMLСтрока(Новый РасширенноеИмяXML(ТипXDTO.URIПространстваИмен, ТипXDTO.Имя))
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Математические процедуры и функции

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//		ИсхСумма   - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность   - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт
	
	Если МассивКоэф.Количество() = 0 Или НЕ ЗначениеЗаполнено(ИсхСумма) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		
		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);
		
		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;
		
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[К];
	КонецЦикла;
	
	// Погрешности округления отнесем на коэффициент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;
	
	Возврат МассивСумм;
	
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
// 
//  СтрокаСообщенияОбОшибке (необязательный) – Строка – если в процессе установки внешнего соединения возникает ошибка,
//                                                     то подробное описание ошибки помещается в этот параметр
//
// Возвращаемое значение:
//  Тип: COM-объект, Неопределенно.
//  в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
//  в случае ошибки возвращается Неопределенно.
//
Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
	
	Результат = УстановитьВнешнееСоединениеСБазой(Параметры);
	
	ОшибкаПодключенияКомпоненты = Результат.ОшибкаПодключенияКомпоненты;
	СтрокаСообщенияОбОшибке     = Результат.ПодробноеОписаниеОшибки;
	
	Возврат Результат.Соединение;
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
// 
// Возвращаемое значение - структура:
//  Соединение                  - (COM-объект) указатель на COM-объект соединения или Неопределено в случае ошибки
//  КраткоеОписаниеОшибки       - (Строка) краткое описание ошибки
//  ПодробноеОписаниеОшибки     - (Строка) подробное описание ошибки
//  ОшибкаПодключенияКомпоненты - (Булево) флаг ошибки подключения COM
//
Функция УстановитьВнешнееСоединениеСБазой(Параметры) Экспорт
	
	Результат = Новый Структура("Соединение, КраткоеОписаниеОшибки, ПодробноеОписаниеОшибки, ОшибкаПодключенияКомпоненты",
	Неопределено, "", "", Ложь
	);
	
	Попытка
		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // "V82.COMConnector"
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
		Возврат Результат;
	КонецПопытки;
	
	Если Параметры.ВариантРаботыИнформационнойБазы = 0 Тогда
		// Файловый режим
		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			
		Иначе
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",           Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",        Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	Иначе 
		// Клиент-серверный вариант работы информационной базы
		Если ПустаяСтрока(Параметры.ИмяСервера1СПредприятия) Или ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не заданы обязательные параметры подключения: ""Имя сервера""; ""Имя информационной базы на сервере"".'");
			
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			
		Иначе
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",                             Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",                          Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		Результат.Соединение = COMConnector.Connect(СтрокаСоединения);
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
	КонецПопытки;
	
	Возврат Результат;
КонецФункции

// Переводит параметры сеанса в состояние "Не установлено". 
// 
// Параметры: 
// ПараметрыДляОчистки - Строка - имена параметров сеанса для очистки, разделенные ","
// Исключения          - Строка - имена параметров сеанса не предназначенные для очистки, разделенные ","
//
Процедура ОчиститьПараметрыСеанса(ПараметрыДляОчистки = "", Исключения = "") Экспорт
	
	МассивИсключений           = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Исключения);
	МассивПараметровДляОчистки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПараметрыДляОчистки);
	
	Если МассивПараметровДляОчистки.Количество() = 0 Тогда
		Для Каждого ПараметрСеанса Из Метаданные.ПараметрыСеанса Цикл
			Если МассивИсключений.Найти(ПараметрСеанса.Имя) = Неопределено Тогда
				МассивПараметровДляОчистки.Добавить(ПараметрСеанса.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Индекс = МассивПараметровДляОчистки.Найти("ПараметрыКлиентаНаСервере");
	Если Индекс > 0 Тогда
		МассивПараметровДляОчистки.Удалить(Индекс);
	КонецЕсли;
	
	ПараметрыСеанса.Очистить(МассивПараметровДляОчистки);
	
КонецПроцедуры

// Возвращает описание предмета в виде текстовой строки.
// 
// Параметры
//  СсылкаНаПредмет  – ЛюбаяСсылка – объект ссылочного типа.
//
// Возвращаемое значение:
//   Строка 
// 
Функция ПредметСтрокой(СсылкаНаПредмет) Экспорт
	
	Результат = "";
	
	ОбработчикиСобытия = ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриОпределенииПредставленияПредмета");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииПредставленияПредмета(СсылкаНаПредмет, Результат);
	КонецЦикла;
	
	ОбщегоНазначенияПереопределяемый.УстановитьПредставлениеПредмета(СсылкаНаПредмет, Результат);
	
	Если ПустаяСтрока(Результат) Тогда
		Если СсылкаНаПредмет = Неопределено или СсылкаНаПредмет.Пустая() Тогда
			Результат = НСтр("ru = 'не задан'");
		ИначеЕсли Метаданные.Документы.Содержит(СсылкаНаПредмет.Метаданные()) Тогда
			Результат = Строка(СсылкаНаПредмет);
		Иначе
			ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().ПредставлениеОбъекта;
			Если ПустаяСтрока(ПредставлениеОбъекта) Тогда
				ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().Представление();
			КонецЕсли;
			Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"%1 (%2)", Строка(СсылкаНаПредмет), ПредставлениеОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует из исходной строки СтрокаПоиска строку для поиска данных в запросе
//
// Параметры:
//	СтрокаПоиска - Строка - исходная строка, содержащая запрещенные символы 	
//
// Возвращаемое значение:
//  Строка - строка подготовленная для поиска данных в запросе
//
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Определяет доступность объекта метаданных по функциональным опциям.
//   Вызывающие функции кэшированы в целях оптимизации.
//
// Параметры:
//   ОбъектМетаданных (ОбъектМетаданных)
//
// Возвращаемое значение: 
//   (Булево) Истина если объект доступен.
//
Функция ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Экспорт
	Содержится = Ложь;
	Доступен = Ложь;
	
	Параметры = Новый Структура;
	Для Каждого ФункциональнаяОпция Из Метаданные.ФункциональныеОпции Цикл
		Если ФункциональнаяОпция.Состав.Содержит(ОбъектМетаданных) Тогда
			Содержится = Истина;
			Значение = ПолучитьФункциональнуюОпцию(ФункциональнаяОпция.Имя, Параметры);
			Если Значение = Истина Тогда
				Доступен = Истина;
				Прервать;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат НЕ Содержится ИЛИ Доступен;
КонецФункции // ОбъектМетаданныхДоступенПоФункциональнымОпциям

// Устанавливает или снимает пометку удаления для всех объектов, которые ссылаются на заданный "объект-владелец".
//
//  Параметры:
// Владелец – ПланОбменаСсылка, СправочникСсылка, ДокументСсылка и пр. 
// Ссылка на объект, который является "владельцем" по отношению к помечаемым на удаление объектам.
//
// ПометкаУдаления – Булево. Признак установки/снятия пометки на удаление у всех "подчиненных" объектов.
// Истина - пометка будет установлена; Ложь - пометка будет снята.
//
Процедура УстановитьПометкуУдаленияПодчиненнымОбъектам(Знач Владелец, Знач ПометкаУдаления) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		СписокСсылок = Новый Массив;
		СписокСсылок.Добавить(Владелец);
		Ссылки = НайтиПоСсылкам(СписокСсылок);
		
		Для Каждого Ссылка из Ссылки Цикл
			
			Если ЗначениеСсылочногоТипа(Ссылка[1]) Тогда
				
				Ссылка[1].ПолучитьОбъект().УстановитьПометкуУдаления(ПометкаУдаления);
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Пытается выполнить запрос в несколько попыток.
// Используется для чтения вне транзакции часто изменяемых данных.
// При вызове в транзакции выдает ошибку.
//
// Параметры:
//  Запрос - Запрос - запрос который требуется выполнить
//
// Возвращаемое значение:
//  РезультатЗапроса - результат выполнения запроса
//
Функция ВыполнитьЗапросВнеТранзакции(Знач Запрос) Экспорт
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение(НСтр("ru = 'Транзакция активна. Выполнение запроса вне транзакции невозможно.'"));
	КонецЕсли;
	
	КоличествоПопыток = 0;
	
	Результат = Неопределено;
	Пока Истина Цикл
		Попытка
			Результат = Запрос.Выполнить(); // Чтение вне транзакции, возможно появление ошибки 
			                                // Could not continue scan with NOLOCK due to data movement
			                                // в этом случае нужно повторить попытку чтения
			Прервать;
		Исключение
			КоличествоПопыток = КоличествоПопыток + 1;
			Если КоличествоПопыток = 5 Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с формами

// Процедура предназначена для заполнения реквизита формы типа «ДеревоЗначений»
//
// Параметры:
// КоллекцияЭлементовДерева – реквизит формы, который имеет тип «ДеревоЗначений»;
// 							  реквизит заполняется значениями из второго параметра процедуры.
// ДеревоЗначений           – ДеревоЗначений – параметр содержит данные для заполнения.
// 
Процедура ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(КоллекцияЭлементовДерева, ДеревоЗначений) Экспорт
	
	Для Каждого Строка Из ДеревоЗначений.Строки Цикл
		
		ЭлементДерева = КоллекцияЭлементовДерева.Добавить();
		
		ЗаполнитьЗначенияСвойств(ЭлементДерева, Строка);
		
		Если Строка.Строки.Количество() > 0 Тогда
			
			ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(ЭлементДерева.ПолучитьЭлементы(), Строка);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Получает картинку для вывода на странице с комментарием в зависимости
// от наличия текста в комментарии.
//
// Параметры
//  Комментарий  - Строка - текст комментария
//
// Возвращаемое значение:
//  Картинка - Картинка, которая должна отображаться на странице с комментарием.
//
Функция ПолучитьКартинкуКомментария(Комментарий) Экспорт
	
	Если НЕ ПустаяСтрока(Комментарий) Тогда
		Картинка = БиблиотекаКартинок.Комментарий;
	Иначе
		Картинка = Новый Картинка;
	КонецЕсли;
	
	Возврат Картинка;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
//
// Параметры:
// Отбор – Структура – содержит значения элементов отбора.
//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором. 
//						Ключ (Строка) – имя свойства элемента метаданных;
//						Значение (Массив) – множество значений для отбора.
//
// Пример инициализации переменной "Отбор":
//
// Массив = Новый Массив;
// Массив.Добавить("Константа.ИспользоватьСинхронизациюДанных");
// Массив.Добавить("Справочник.Валюты");
// Массив.Добавить("Справочник.Организации");
// Отбор = Новый Структура;
// Отбор.Вставить("ПолноеИмя", Массив);
// 
//  Возвращаемое значение:
//  Тип: ДеревоЗначений - дерево описания метаданных конфигурации
//
Функция ПолучитьДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
	
	ИспользоватьОтбор = (Отбор <> Неопределено);
	
	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
	
	НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               "Константы",                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             "Справочники",               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               "Документы",                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             "Планы счетов",              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        "Регистры сведений",         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      "Регистры накопления",       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     "Регистры бухгалтерии",      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         "Регистры расчета",          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          "Бизнес-процессы",           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  "Задачи",                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
	
	// возвращаемое значение функции
	ДеревоМетаданных = Новый ДеревоЗначений;
	ДеревоМетаданных.Колонки.Добавить("Имя");
	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
	ДеревоМетаданных.Колонки.Добавить("Синоним");
	ДеревоМетаданных.Колонки.Добавить("Картинка");
	
	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
		
		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
			
			Если ИспользоватьОтбор Тогда
				
				ОбъектПрошелФильтр = Истина;
				Для Каждого ЭлементОтбора Из Отбор Цикл
					
					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
						ОбъектПрошелФильтр = Ложь;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбъектПрошелФильтр Тогда
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
			
			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// удаляем строки без подчиненных элементов
	Если ИспользоватьОтбор Тогда
		
		// используем обратный порядок обхода дерева значений
		КолвоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
			
			ТекущийИндекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
			Если СтрокаДерева.Строки.Количество() = 0 Тогда
				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат ДеревоМетаданных;
	
КонецФункции

// Получить представление физического места размещения информационной базы для отображения администратору.
//
// Возвращаемое значение:
//   Строка      - представление информационной базы
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		Возврат Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	КонецЕсли;
		
	// Прибавить к имени сервера имя пути информационной базы
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	НачальнаяПозицияКопирования = 6 + 1;
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	
	СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
	
	// Позиция имени сервера
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "REF=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НачальнаяПозицияКопирования = 6;
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
	Возврат ПутьКБД;
	
КонецФункции

// Возвращает строку реквизитов объекта метаданных с заданным типом
//
// Параметры:
//  Ссылка – ЛюбаяСсылка – ссылка на элемент базы данных, для которого требуется получить результат функции
//  Тип    – Тип – тип значения реквизита
// 
//  Возвращаемое значение:
// Тип: Строка – строка реквизитов объекта метаданных конфигурации, разделенные символом ","
//
Функция ИменаРеквизитовПоТипу(Ссылка, Тип) Экспорт
	
	Результат = "";
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Если Реквизит.Тип.СодержитТип(Тип) Тогда
			Результат = Результат + ?(ПустаяСтрока(Результат), "", ", ") + Реквизит.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает менеджер объекта по ссылке на объект
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Функция ВидОбъектаПоСсылке возвращает имя вида объектов метаданных
// по ссылке на объект.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоСсылке(Ссылка) Экспорт
	
	Возврат ВидОбъектаПоТипу(ТипЗнч(Ссылка));
	
КонецФункции 

// Проверить, что значение имеет ссылочный тип данных.
//
// Параметры:
//  Значение       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Булево       - Истина, если тип значения ссылочный.
//
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Задачи.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет является ли объект группой элементов.
//
// Параметры:
//  Объект       - Объект, Ссылка, ДанныеФормыСтруктура по типу Объект.
//
// Возвращаемое значение:
//  Булево.
//
Функция ОбъектЯвляетсяГруппой(Объект) Экспорт
	
	Если ЗначениеСсылочногоТипа(Объект) Тогда
		Ссылка = Объект;
	Иначе
		Ссылка = Объект.Ссылка;
	КонецЕсли;
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Если ЭтоСправочник(МетаданныеОбъекта) Тогда
		
		Если НЕ МетаданныеОбъекта.Иерархический
		 ИЛИ МетаданныеОбъекта.ВидИерархии
		     <> Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			
			Возврат Ложь;
		КонецЕсли;
		
	ИначеЕсли НЕ ЭтоПланВидовХарактеристик(МетаданныеОбъекта) Тогда
		Возврат Ложь;
		
	ИначеЕсли НЕ МетаданныеОбъекта.Иерархический Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Ссылка <> Объект Тогда
		Возврат Объект.ЭтоГруппа;
	КонецЕсли;
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, "ЭтоГруппа");
	
КонецФункции

// Возвращает строковое представление типа. 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
// Для остальных типов приводит тип к строке, например "Число".
//
Функция СтроковоеПредставлениеТипа(Тип) Экспорт
	
	Представление = "";
	
	Если ЭтоСсылка(Тип) Тогда
	
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];
		
		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "СправочникСсылка";
		
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ДокументСсылка";
		
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "БизнесПроцессСсылка";
		
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовХарактеристикСсылка";
		
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланСчетовСсылка";
		
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовРасчетаСсылка";
		
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ЗадачаСсылка";
		
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланОбменаСсылка";
		
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПеречислениеСсылка";
		
		КонецЕсли;
		
		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
		
	Иначе
		
		Результат = Строка(Тип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверить, что описание типа состоит из единственного типа значения и 
// совпадает с нужным типом.
//
// Возвращаемое значение:
//   Булево      - Совпадает или нет
//
Функция ОписаниеТипаСостоитИзТипа(ОписаниеТипа, ТипЗначения) Экспорт
	
	Если ОписаниеТипа.Типы().Количество() = 1
	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции

// Проверяет наличие табличной части у справочника
//
//Параметры
//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
//
//Возвращаемое значение:
//  Булево   - Истина, если табличная часть есть, ложь в обратном случае
//
//Пример:
//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
//  	Возврат;
//  КонецЕсли;
//
Функция НаличиеТабличнойЧастиУСправочника(ИмяСправочника, ИмяТабличнойЧасти) Экспорт
	
	Возврат (Метаданные.Справочники[ИмяСправочника].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
	
КонецФункции 

// Формирует расширенное представление объекта.
// Расширенное представление объекта складывается из представления объекта, кода и наименования.
// Если для объекта не удалось получить расширенное представление,
// то возвращается стандартное представление объекта, формируемое платформой.
//
// Пример возвращаемого значения функции:
// "Контрагент 0А-0001234, ООО Телекоммуникационные системы"
//
//  Параметры:
// Объект. Тип: СправочникСсылка,
//				ПланСчетовСсылка,
//				ПланОбменаСсылка,
//				ПланВидовХарактеристикСсылка,
//				ПланВидовРасчетаСсылка.
// Объект, для которого требуется получить расширенное представление.
//
//  Возвращаемое значение:
// Тип. Строка.
// Расширенное представление объекта.
//
Функция РасширенноеПредставлениеОбъекта(Объект) Экспорт
	
	ОбъектМетаданных = Объект.Метаданные();
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Если    ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета()
		Тогда
		
		Если  ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Код")
			И ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Наименование") Тогда
			
			ЗначенияРеквизитов = ЗначенияРеквизитовОбъекта(Объект, "Код, Наименование");
			
			ПредставлениеОбъекта = ?(ПустаяСтрока(ОбъектМетаданных.ПредставлениеОбъекта), 
										?(ПустаяСтрока(ОбъектМетаданных.Синоним), ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним
										),
									ОбъектМетаданных.ПредставлениеОбъекта
			);
			
			Результат = "[ПредставлениеОбъекта] [Код], [Наименование]";
			Результат = СтрЗаменить(Результат, "[ПредставлениеОбъекта]", ПредставлениеОбъекта);
			Результат = СтрЗаменить(Результат, "[Код]",          ?(ПустаяСтрока(ЗначенияРеквизитов.Код), "<>", ЗначенияРеквизитов.Код));
			Результат = СтрЗаменить(Результат, "[Наименование]", ?(ПустаяСтрока(ЗначенияРеквизитов.Наименование), "<>", ЗначенияРеквизитов.Наименование));
			
		Иначе
			
			Результат = Строка(Объект);
			
		КонецЕсли;
		
	Иначе
		
		Результат = Строка(Объект);
		
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного
// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора)
//
// Параметры:
//  ОбъектМетаданных  - Объект метаданных конфигурации, для которого необходимо получить значение свойств реквизитов.
//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
//  Свойства - Строка - свойства реквизитов, перечисленных через запятую, значение которых необходимо получить.
//                      Например: "Имя, Тип, Синоним, Подсказка"
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица значений с описанием требуемых свойств всех реквизитов объекта метаданного
//
Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
	
	МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	
	// возвращаемое значение функции
	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
	
	// добавляем в таблицу поля согласно именам переданных свойств
	Для Каждого ИмяСвойства ИЗ МассивСвойств Цикл
		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
	КонецЦикла;
	
	// заполняем строку таблицы свойствами реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.СтандартныеРеквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	Возврат ТаблицаОписанияСвойствОбъекта;
	
КонецФункции

// Возвращает состояние использования элемента состава общего реквизита
//
// Параметры:
//  ЭлементСостава - ОбъектМетаданных - элемент состава общего реквизита использование
//   которого требуется проверить
//  МетаданныеОбщегоРеквизита - ОбъектМетаданных - метаданные общего реквизита,  
//   которому принадлежит ЭлементСостава
//
// Возвращаемое значение:
//  Булево - Истина, если элемент состава используется, иначе Ложь
//
Функция ЭлементСоставаОбщегоРеквизитаИспользуется(Знач ЭлементСостава, Знач МетаданныеОбщегоРеквизита) Экспорт
	
	Если ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать Тогда
		Возврат Истина;
	ИначеЕсли ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.НеИспользовать Тогда
		Возврат Ложь;
	Иначе
		Возврат МетаданныеОбщегоРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с табличными документами

// Проверяет, умещаются ли переданные табличные документы на страницу при печати.
//
// Параметры
//  ТабДокумент        – Табличный документ
//  ВыводимыеОбласти   – Массив из проверяемых таблиц или табличный документ
//  РезультатПриОшибке - Какой возвращать результат при возникновении ошибки
//
// Возвращаемое значение:
//   Булево   – умещаются или нет переданные документы
//
Функция ПроверитьВыводТабличногоДокумента(ТабДокумент, ВыводимыеОбласти, РезультатПриОшибке = Истина) Экспорт

	Попытка
		Возврат ТабДокумент.ПроверитьВывод(ВыводимыеОбласти);
	Исключение
		Возврат РезультатПриОшибке;
	КонецПопытки;

КонецФункции 

// Процедура инициализации разделенной информационной базы
// 
// Параметры:
// ВключитьРазделение - Булево - признак включения разделения в
// информационной базе
//
Процедура УстановитьПараметрыРазделенияИнформационныйБазы(Знач ВключитьРазделение = Ложь) Экспорт
	
	Если ВключитьРазделение Тогда
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Истина);
	Иначе
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает значение двух дополнительных констант.
// Имена констант строго регламентированы и должны соответствовать шаблонам:
//  <Имя основной константы>ВМоделиСервиса
//  <Имя основной константы>ВЛокальномРежиме
//
// Параметры:
//  Значение – Булево – значение основной константы.
//  ИмяКонстанты – Строка – имя основной константы.
//
Процедура УстановитьЗначенияДополнительныхКонстант(Знач Значение, Знач ИмяКонстанты, Знач МенеджерЗначения) Экспорт
	
	Если Значение = Истина Тогда
		
		РазделениеВключено = ОбщегоНазначенияПовтИсп.РазделениеВключено();
		
		УстановитьЗначениеКонстанты(РазделениеВключено, ИмяКонстанты + "ВМоделиСервиса", МенеджерЗначения);
		УстановитьЗначениеКонстанты(Не РазделениеВключено, ИмяКонстанты + "ВЛокальномРежиме", МенеджерЗначения);
		
	Иначе
		
		УстановитьЗначениеКонстанты(Ложь, ИмяКонстанты + "ВМоделиСервиса", МенеджерЗначения);
		УстановитьЗначениеКонстанты(Ложь, ИмяКонстанты + "ВЛокальномРежиме", МенеджерЗначения);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьЗначениеКонстанты(Знач Значение, Знач ИмяКонстанты, Знач МенеджерЗначения)
	
	МенеджерКонстанты = Константы[ИмяКонстанты].СоздатьМенеджерЗначения();
	
	Для Каждого ДополнительноеСвойство Из МенеджерЗначения.ДополнительныеСвойства Цикл
		
		МенеджерКонстанты.ДополнительныеСвойства.Вставить(ДополнительноеСвойство.Ключ, ДополнительноеСвойство.Значение);
		
	КонецЦикла;
	
	МенеджерКонстанты.ОбменДанными.Загрузка = МенеджерЗначения.ОбменДанными.Загрузка;
	МенеджерКонстанты.Значение = Значение;
	МенеджерКонстанты.Записать();
	
КонецПроцедуры

// Выполняет запись значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа или УдалениеОбъекта.
//
Процедура ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		Модуль.ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных);
	Иначе
		ОбъектВспомогательныхДанных.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Выполняет удаление значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа.
//
Процедура УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		Модуль.УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных);
	Иначе
		ОбъектВспомогательныхДанных.Удалить();
	КонецЕсли;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Версионирование программных интерфейсов

// Возвращает массив номеров версий, поддерживаемых интерфейсом удаленной системы.
//
// Параметры:
//  ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
//  ИмяИнтерфейса - Строка.
//
// Параметры:
//  Адрес - Строка - адрес web-сервиса версионирования интерфейсов
//  Пользователь - Строка - имя пользователя
//  Пароль - Строка - пароль пользователя
//  Интерфейс - Строка - имя интерфейса
//
//
// Возвращаемое значение:
// ФиксированныйМассив - Массив строк:
//	- Каждая строка является представлением номера версии интерфейса. Например, "1.0.2.1".
//
// Пример использования:
//	  ПараметрыПодключения = Новый Структура;
//	  ПараметрыПодключения.Вставить("URL", "http://vsrvx/sm");
//	  ПараметрыПодключения.Вставить("UserName", "ivanov");
//	  МассивВерсий = ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
//
// Примечание: при получении версий используется кэш, время обновления которого составляет
//  одни сутки. Если для целей отладки требуется обновить значения в кэше, раньше этого 
//  времени, следует удалить из регистра сведений КэшПрограммныхИнтерфейсов соответствующие 
//  записи.
//
Функция ПолучитьВерсииИнтерфейса(Знач Адрес, Знач Пользователь, Знач Пароль = Неопределено, Знач Интерфейс = Неопределено) Экспорт
	
	Если ТипЗнч(Адрес) = Тип("Структура") Тогда
		ПараметрыПодключения = Адрес;
		ИмяИнтерфейса = Пользователь;
	Иначе
		ПараметрыПодключения = Новый Структура;
		ПараметрыПодключения.Вставить("URL", Адрес);
		ПараметрыПодключения.Вставить("UserName", Пользователь);
		ПараметрыПодключения.Вставить("Password", Пароль);
		ИмяИнтерфейса = Интерфейс;
	КонецЕсли;
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	ПараметрыПолучения = Новый Массив;
	ПараметрыПолучения.Добавить(ПараметрыПодключения);
	ПараметрыПолучения.Добавить(ИмяИнтерфейса);
	
	Возврат ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
		ИдентификаторЗаписиКэшаВерсий(ПараметрыПодключения.URL, ИмяИнтерфейса), 
		Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса, 
		ЗначениеВСтрокуXML(ПараметрыПолучения),
		Истина);
	
КонецФункции

// Возвращает массив номеров версий, поддерживаемых интерфейсом системы, подключенной через внешнее соединение.
//
// Параметры:
// ВнешнееСоединение - объект COM-соединение, которое используется для работы с корреспондентом.
// ИмяИнтерфейса - Строка.
//
// Возвращаемое значение:
// ФиксированныйМассив - Массив строк:
//  Каждая строка является представлением номера версии интерфейса. Например, "1.0.2.1".
//
// Пример использования:
//  Параметры = ...
//  ВнешнееСоединение = ОбщегоНазначения.УстановитьВнешнееСоединение(Параметры);
//  МассивВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, "ОбменДанными");
//
Функция ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, Знач ИмяИнтерфейса) Экспорт
	
	Попытка
		ВерсииИнтерфейсаXML = ВнешнееСоединение.СтандартныеПодсистемыСервер.ПоддерживаемыеВерсии(ИмяИнтерфейса);
	Исключение
		СтрокаСообщения = НСтр("ru = 'Корреспондент не поддерживает версионирование интерфейсов подсистем.
			|Описание ошибки: %1'");
		СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение версий интерфейса'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , СтрокаСообщения);
		
		Возврат Новый ФиксированныйМассив(Новый Массив);
	КонецПопытки;
	
	Возврат Новый ФиксированныйМассив(ЗначениеИзСтрокиXML(ВерсииИнтерфейсаXML));
КонецФункции

// Удаляет записи кэша версий содержащих в идентификаторе указанную
// подстроку. В качестве подстроки может использоваться, например,
// имя интерфейса более не используемого в конфигурации.
//
// Параметры:
//  ПодстрокаПоискаИдентификаторов - Строка - подстрока поиска 
//   идентификаторов. Строка не может содержать символов
//   %, _ и [
//
Процедура УдалитьЗаписиКэшаВерсий(Знач ПодстрокаПоискаИдентификаторов) Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ПодстрокаПоиска = СформироватьСтрокуДляПоискаВЗапросе(ПодстрокаПоискаИдентификаторов);

		ТекстЗапроса =
			"ВЫБРАТЬ
			|	ТаблицаКэша.Идентификатор КАК Идентификатор,
			|	ТаблицаКэша.ТипДанных КАК ТипДанных
			|ИЗ
			|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
			|ГДЕ
			|	ТаблицаКэша.Идентификатор ПОДОБНО ""%" + ПодстрокаПоиска + "%""
			|		СПЕЦСИМВОЛ ""~""";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Результат = Запрос.Выполнить();
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Запись = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьМенеджерЗаписи();
			Запись.Идентификатор = Выборка.Идентификатор;
			Запись.ТипДанных = Выборка.ТипДанных;
			
			Запись.Удалить();
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

////////////////////////////////////////////////////////////////////////////////
// Получение обработчиков серверных событий.

// Возвращает структуру для добавления обязательного события.
//
// Возвращаемое значение:
//  Структура - 
//    ИмяСобытия - Строка, представление события.
//       Пример: "СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления".
//
//    Обязательное - Булево, если Истина, то для данного события обязательно объявление обработчиков.
//
Функция НовоеСобытие() Экспорт
	
	Возврат Новый Структура("Имя, Обязательное", "", Ложь);

КонецФункции

// Возвращает обработчики указанного серверного события.
//
// Параметры:
//  Событие  - Строка, например,
//             "СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления".
//
// Возвращаемое значение:
//  ФиксированныйМассив со значениями типа
//    ФиксированнаяСтруктура со свойствами:
//      Версия - Строка      - версия обработчика, например, "2.1.3.4". Пустая строка, если не указана.
//      Модуль - ОбщийМодуль - серверный общий модуль.
// 
Функция ОбработчикиСобытия(Событие) Экспорт
	
	Массив = Новый Массив;
	
	Обработчики = СтандартныеПодсистемыПовтИсп.ОбработчикиСерверногоСобытия(Событие, Ложь);
	Для каждого Обработчик Из Обработчики Цикл
		
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль(Обработчик.Модуль);
		
		Элемент = Новый Структура;
		Элемент.Вставить("Модуль",     Модуль);
		Элемент.Вставить("Версия",     Обработчик.Версия);
		Элемент.Вставить("Подсистема", Обработчик.Подсистема);
		
		Массив.Добавить(Новый ФиксированнаяСтруктура(Элемент));
	КонецЦикла;
	
	Возврат Новый ФиксированныйМассив(Массив);
	
КонецФункции

// Формирует идентификатор записи кэша версий из адреса сервера и имени ресурса
//
// Параметры:
//  Адрес - Строка - адрес сервера
//  Имя - Имя - имя ресурса
//
// Возвращаемое значение:
//  Строка - идентификатор записи кэша версий 
//
Функция ИдентификаторЗаписиКэшаВерсий(Знач Адрес, Знач Имя) Экспорт
	
	Возврат Адрес + "|" + Имя;
	
КонецФункции

// Устарела. Следует использовать ЕстьСсылкиНаОбъект.
Функция ОбъектИспользуютсяВБазеДанных(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь) Экспорт
	Возврат ЕстьСсылкиНаОбъект(СсылкаИлиМассивСсылок, ИскатьСредиСлужебныхОбъектов);
КонецФункции

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку.
Функция КлючиСтруктурыВСтроку(Структура, Разделитель = ",") Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку(Структура, Разделитель);
	
КонецФункции

Процедура НоваяСтрокаКоллекцииОбъектовМетаданных(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
	
	НоваяСтрока = Таб.Добавить();
	НоваяСтрока.Имя               = Имя;
	НоваяСтрока.Синоним           = Синоним;
	НоваяСтрока.Картинка          = Картинка;
	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура ПриУстановкеРазделенияСеанса(Знач Использование, Знач ОбластьДанных = Неопределено)
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("РаботаВМоделиСервиса");
		Модуль.УстановитьРазделениеСеанса(Использование, ОбластьДанных);
	КонецЕсли;
	
КонецПроцедуры

// Заполнение отбора значениями из таблицы значений.
// Соответствие полей устанавливается по представлению и типам значений
//
// Параметры
//  Отбор  – Отбор           – Отбор, который требуется заполнить значениями
//  ТЗ     – ТаблицаЗначений – Таблица содержит значения для отбора.
//                             Структура колонок повторяет структуру отбора
//
Процедура ЗаполнитьОтборПоТаблицеЗначений(Отбор, ТЗ) Экспорт

	Для каждого ЭлементОтбора Из ТЗ Цикл
	
		СтрокаТаблицы = Неопределено;
		
		Для каждого стр Из Отбор Цикл
			
			Если стр.Представление = ЭлементОтбора.Представление
				И стр.ТипЗначения = ЭлементОтбора.ТипЗначения Тогда
				Если ПустаяСтрока(стр.Представление)
					И ПустаяСтрока(стр.ПутьКданным) Тогда
					
					Продолжить;
					
				КонецЕсли;
				СтрокаТаблицы = стр;
				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ПустаяСтрока(ЭлементОтбора.ПутьКданным) Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрокаТаблицы = Неопределено Тогда
			
			СтрокаТаблицы = Отбор.Добавить(ЭлементОтбора.ПутьКданным, ЭлементОтбора.Имя, ЭлементОтбора.Представление);		
					
		КонецЕсли;
		
		СтрокаТаблицы.ВидСравнения = ЭлементОтбора.ВидСравнения;
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, ЭлементОтбора, "Значение, ЗначениеПо, ЗначениеС, Использование");
			
	КонецЦикла;

КонецПроцедуры // УстановитьОтборИзТаблицы(Отбор, ТЗ)

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, ЦелоеЧисло) Экспорт

	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

// Функция предназначена для формирования массива префиксов.
//
// Возвращаемое значение.
//  Массив префиксов
//
Функция ПолучитьМассивПрефиксовРИБ() Экспорт
	
	МассивПрефиксов = Новый Массив();
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ Различные
	               |	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	               |ИЗ
	               |	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
	
	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			
			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
			
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Функция предназначена для формирования массива префиксов.
//
// Параметры:
//  Организация - (СправочникСсылка), дял которой нужно получить префиксы.
//
// Возвращаемое значение.
//  Массив префиксов
//
Функция СформироватьМассивПрефиксовДляРИБИОрганизации(Организация) Экспорт
	
	МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();
	
	Если ЗначениеЗаполнено(Организация) Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			МассивПрефиксов.Добавить(Префикс);
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		МассивПрефиксов.Добавить("");
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

Функция СформироватьМассивПрефиксовПоОрганизации(Организация) Экспорт
	
	МассивПрефиксов = Новый Массив;
	 
	 Если ЗначениеЗаполнено(Организация) Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			
			МассивПрефиксов.Добавить(Префикс);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		
		МассивПрефиксов.Добавить("");
		
	КонецЕсли;
	
	Возврат МассивПрефиксов;

КонецФункции	

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта) Экспорт

	Если Валюта.ПараметрыПрописиНаРусском = "" Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма, "L=ru_RU", Валюта.ПараметрыПрописиНаРусском);
	КонецЕсли;

КонецФункции // СформироватьСуммуПрописью()

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "") Экспорт
	
	Если ДокументОбъект = Неопределено Тогда
		Возврат "";
	Иначе
		Возврат ?(НЕ ЗначениеЗаполнено(НазваниеДокумента), ДокументОбъект.Метаданные().Синоним, НазваниеДокумента) + " № " + ПолучитьНомерНаПечать(ДокументОбъект)
		                          + " от " + Формат(ДокументОбъект.Дата, "ДФ='дд ММММ гггг'") + " г.";
	КонецЕсли;

КонецФункции // СформироватьЗаголовокДокумента()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Функция возвращает значение реквизита произвольного объекта ссылочного типа
// Предназначена для получения реквизитов недоступных пользователю объектов
Функция ПолучитьРеквизитОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	ОбъектМетаданные = Ссылка.Метаданные();
	ИмяТаблицы = ОбъектМетаданные.ПолноеИмя();
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ " + ИмяРеквизита + " КАК " + ИмяРеквизита + " ИЗ " + ИмяТаблицы + "
	|ГДЕ Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка[ИмяРеквизита];
	Иначе
		РеквизитМетаданные = ОбъектМетаданные.Реквизиты.Найти(ИмяРеквизита);
		Возврат РеквизитМетаданные.Тип.ПривестиЗначение();
	КонецЕсли;
		
КонецФункции //ПолучитьРеквизитОбъекта()

// Предназначена для получения пустого значения заданного типа:
// примитивного, или ссылочного.
//
// Параметры:
//  ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьТабЧастьДокумента()

// Позволяет определить есть ли среди реквизитов шапки отчета
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита     - строковое имя искомого реквизита, 
//  МетаданныеОтчета - метаданные отчета, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОтчета(ИмяРеквизита, МетаданныеОтчета) Экспорт

	Если МетаданныеОтчета.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьРеквизитОтчета()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;
	Иначе
		Если ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Истина;
	КонецЕсли;
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	Длина = СтрДлина(СтрокаПроверки);
	
	Для а = 1 По Длина Цикл
		Если Найти("0123456789", Сред(СтрокаПроверки, а, 1)) = 0 Тогда
			Возврат Истина;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Служебная функция - возвращает принадлежность объекта метаданных определенному классу
// 
// Параметры:
//  Класс  - класс
//  Объект - объект метаданных
// 
Функция ПринадлежностьКлассуМетаданных(Класс, Объект) Экспорт
	Для Каждого МДОбъект Из Метаданные[Класс] Цикл
		Если МДОбъект = Объект Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции // ПринадлежностьКлассуМетаданных()

// Служебная функция, предназначенная для получения описания типов набора записей по объекту метаданных
// Параметры:
//  Объект - объект метаданных
//
// Возвращаемое значение:
// Описание типов с единственным типом набора записей
//
Функция ПолучитьОписаниеТиповНабораЗаписей(Объект) Экспорт
	
	Массив = Новый Массив;
	Если ПринадлежностьКлассуМетаданных("РегистрыРасчета", Объект) Тогда
		Массив.Добавить(Тип("РегистрРасчетаНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыБухгалтерии", Объект) Тогда
		Массив.Добавить(Тип("РегистрБухгалтерииНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыНакопления", Объект) Тогда
		Массив.Добавить(Тип("РегистрНакопленияНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыСведений", Объект) Тогда
		Массив.Добавить(Тип("РегистрСведенийНаборЗаписей."+Объект.Имя));
	КонецЕсли;
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции  // ПолучитьОписаниеТиповНабораЗаписей()

//функция выполняет приведение строки к числу
// Параметры:
//  ЧислоСтрокой           - Строка - Строка приводимая к числу
//  ВозвращатьНеопределено - Булево - Если Истина и строка содержит некорректное значение, то возвращать Неопределено
//
// Возвращаемое значение:
//  Число
//
Функция ПривестиСтрокуКЧислу(ЧислоСтрокой, ВозвращатьНеопределено = Ложь) Экспорт
	
	ОписаниеТипаЧисла = Новый ОписаниеТипов("Число");
	ЗначениеЧисла = ОписаниеТипаЧисла.ПривестиЗначение(ЧислоСтрокой);
	
	Если ВозвращатьНеопределено И (ЗначениеЧисла = 0) Тогда
		
		Стр = Строка(ЧислоСтрокой);
		Если Стр = "" Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Стр = СтрЗаменить(СокрЛП(Стр), "0", "");
		Если (Стр <> "") И (Стр <> ".") И (Стр <> ",") Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеЧисла;	
	
КонецФункции

// Функция выполняет приведение строки к дате
Функция ПривестиСтрокуКДате(ДатаСтрокой) Экспорт
	
	ОписаниеТипаДаты = Новый ОписаниеТипов("Дата");
	ЗначениеДаты = ОписаниеТипаДаты.ПривестиЗначение(ДатаСтрокой);
	
	Возврат ЗначениеДаты;
	
КонецФункции

// Функция выполняет приведение строки к булево
Функция ПривестиСтрокуКБулево(БулевоСтрокой) Экспорт
	
	ОписаниеТипаБулево = Новый ОписаниеТипов("Булево");
	ЗначениеБулево = ОписаниеТипаБулево.ПривестиЗначение(БулевоСтрокой);
	
	Возврат ЗначениеБулево;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СВОЙСТВАМИ И КАТЕГОРИЯМИ ОБЪЕКТОВ

//Функция возвращает список доступных назначений для "Свойств и категорий объектов" 
//по переданной ссылке
// Параметры:
//Ссылка - Ссылка на справочник или документ
//
// Возвращаемое значение:
// Список значений: доступные назначения для свойств и категорий
Функция ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(Ссылка) Экспорт

	Результат = Новый СписокЗначений;

	ТипСсылки = ТипЗнч(Ссылка);
	ЭтоХарактеристика = (ТипСсылки = Тип("СправочникСсылка.ХарактеристикиНоменклатуры"));

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НазначениеХарактеристика", ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры);

	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Назначения.Ссылка КАК Ссылка,
	|	Назначения.ТипЗначения КАК ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
	|ГДЕ
	|	НЕ Назначения.ПометкаУдаления
	|	И НЕ Назначения.ЭтоГруппа
	|";

	Если ЭтоХарактеристика Тогда
		ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка = &НазначениеХарактеристика
		|";
	Иначе
		ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка <> &НазначениеХарактеристика
		|";
	КонецЕсли;

	Запрос.Текст = ТекстЗапроса;

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ЭтоХарактеристика Или Выборка.ТипЗначения.СодержитТип(ТипСсылки) Тогда
			Результат.Добавить(Выборка.Ссылка);
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции // ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// Сравнивает два массива однотипных значений (кроме коллекций значений)
//
// Параметры: 
//  ПервыйМассив,ВторойМассив - сравниваемые массивы
//
// Возвращаемое значение:
//  булево.
//
Функция МассивыИдентичны(ПервыйМассив,ВторойМассив) Экспорт

    ЭлементовМассива = ПервыйМассив.Количество();
	МассивыСовпадают = (ЭлементовМассива = ВторойМассив.Количество()); 
	  
	Если МассивыСовпадают Тогда
		Для Сч = 1 По ЭлементовМассива Цикл
			Если ПервыйМассив[Сч-1] <> ВторойМассив[Сч-1] Тогда
				Возврат Ложь
			КонецЕсли;
		КонецЦикла; 		
	КонецЕсли;

	Возврат МассивыСовпадают

КонецФункции // МассивыИдентичны()

////////////////////////////////////////////////////////////////////////////////
//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ

// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		Сообщить("Неверный тип универсальной коллекции для копирования");
		Возврат Неопределено
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

Процедура СообщитьИнформациюПользователю(СтрокаСообщенияПользователю) Экспорт
	
	#Если Клиент Тогда
	Сообщить(СтрокаСообщенияПользователю);
	#КонецЕсли
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;

КонецФункции // ПолучитьСписокЭлементовПеречисления()

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//  Элемент перечисления.
//
// Возвращаемое значение:
//  Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
	Возврат ИмяТабличнойЧасти;

КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

// Функция возвращает метаданные документа, которому принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Метаданные - метаданные документа, как оно задано в конфигураторе
//
Функция ПолучитьМетаданныеДокументаПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Родитель();
	Возврат МетаданныеДокумента;

КонецФункции // ПолучитьМетаданныеДокументаПоСсылкеНаСтроку()

// Процедура предназначена для получения момента определения остатков для заполнения документа.
//
// Параметры:
//  ДокОбъект - (ДокументОбъект), документ, для которого надо определить лату получения остатков.
//
// Возвращаемое значение.
//  Дата (момент времени) - дата остатков
//
Функция ПолучитьДатуОстатков(ДокОбъект) Экспорт
	
	ДатаОстатков = '00010101';
	Если НачалоДня(ДокОбъект.Дата) <> НачалоДня(ТекущаяДата()) 
	   И ДокОбъект.Дата <> '00010101' Тогда
	   
		Если НЕ ЗначениеЗаполнено(ДокОбъект.Ссылка) Тогда
			ДатаОстатков = КонецДня(ДокОбъект.Дата);
		Иначе
			ДатаОстатков = ДокОбъект.МоментВремени();
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ДатаОстатков;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Процедура удаления существующих движений документа при перепроведении (отмене проведения)
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ) Экспорт
	
	МассивОбрабатываемыхСтрокТаблицыДвижений = Новый Массив();
	
	// получение списка регистров, по которым существуют движения
	ТаблицаДвижений = ПолныеПрава.ОпределитьНаличиеДвиженийПоРегистратору(ДокументОбъект.Ссылка);
	ТаблицаДвижений.Колонки.Добавить("НаборЗаписей");
	ТаблицаДвижений.Колонки.Добавить("БезусловноеУдаление", Новый ОписаниеТипов("Булево"));
		
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		// имя регистра передается как значение, полученное с помощью
		// функции ПолноеИмя() метаданных регистра
		ПозицияТочки = Найти(СтрокаДвижения.Имя, ".");
		ТипРегистра = Лев(СтрокаДвижения.Имя, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(СтрокаДвижения.Имя, ПозицияТочки + 1));

		МассивОбрабатываемыхСтрокТаблицыДвижений.Добавить(СтрокаДвижения);
		
		ЕСли ТипРегистра = "РегистрНакопления" Тогда
			Набор = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
				
		ИначеЕсли ТипРегистра = "РегистрСведений" Тогда
			Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();  			
				
		КонецЕсли;

		Если НЕ ПравоДоступа("Изменение", Набор.Метаданные()) Тогда
			// отсутствуют права на всю таблицу регистра
			СообщитьОбОшибке("Нарушение прав доступа", Отказ, СтрокаДвижения.Имя);
			Возврат;
		КонецЕсли;

		Набор.Отбор.Регистратор.Установить(ДокументОбъект.Ссылка);			

		// набор не записывается сразу, чтобы не откатывать транзакцию, если впоследствии
		// выяснится, что на один из регистров не хватает прав.		
		СтрокаДвижения.НаборЗаписей = Набор;		
		
	КонецЦикла;	
	
	Для Каждого СтрокаДвижения ИЗ МассивОбрабатываемыхСтрокТаблицыДвижений Цикл		
		Если СтрокаДвижения.БезусловноеУдаление Тогда
			ПолныеПрава.ЗаписатьНаборЗаписейНаСервере(СтрокаДвижения.НаборЗаписей, ДокументОбъект.Ссылка);
		Иначе		
			Попытка
				СтрокаДвижения.НаборЗаписей.Записать();
			Исключение
				// возможно «сработал» RLS или механизм даты запрета изменения
				СообщитьОбОшибке(ОписаниеОшибки(), Отказ, СтрокаДвижения.Имя);
				ВызватьИсключение "Операция не выполнена";
			КонецПопытки;
		КонецЕсли;	
	КонецЦикла;
	
	ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
	
	// Удаление записей регистрации из всех последовательностей
	УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);

КонецПроцедуры

// Процедура очищает коллекцию движений документа
//
Процедура ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект) Экспорт
		
	Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
		Если Движение.Количество() > 0 Тогда
			Движение.Очистить();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
//
// Параметры
//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
//
//  Реквизиты – структура – Структура реквизитов. 
//             Ключ     - Наименование колонки в источнике
//             Значение - Наименование колонки в получаемой ТЗ, если значение опущено - приравнивается ключу.
//  ПолучитьНомерСтрокиДокумента - булево
//                                 Используется только при выгрузке из табличной части документа.
//                                 В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
//                                 и заполняет её реальными номерами строк
//
//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
//
// Возвращаемое значение:
//  Таблица значений или Неопределено (если не хватает реквизитов)
//
Функция СформироватьТаблицуЗначений(Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено) экспорт

	ЭтоТаблицаЗначений=(ТипЗнч(Источник)= тип("ТаблицаЗначений"));
	ЭтоСтрокиДереваЗначений=(ТипЗнч(Источник)= тип("КоллекцияСтрокДереваЗначений"));
	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
		Возврат Неопределено;
	Конецесли;
	
	Если НЕ ЗначениеЗаполнено(Реквизиты) тогда
		Если ЭтоТаблицаЗначений тогда
			НоваяТЗ = Источник.Скопировать();
	  		Возврат НоваяТЗ;
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			Реквизиты = Новый Структура();
			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
				Реквизиты.Вставить(Колонка.Имя);
			КонецЦикла;
		Иначе
			НоваяТЗ = Источник.Выгрузить();
	  		Возврат НоваяТЗ;
		КонецЕслИ;
	Конецесли;
	
	Если не ЭтоТаблицаЗначений  и не ЭтоСтрокиДереваЗначений тогда
		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
	Конецесли;
	
	НоваяТЗ= Новый ТаблицаЗначений();
	
	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
 		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",ПолучитьОписаниеТиповЧисла(5,0));
	КонецЕсли;

	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
		Строка = НоваяТЗ.Добавить();
		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТекРеквизит из Реквизиты Цикл
		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
		Если ЭтоТаблицаЗначений тогда
			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
		Иначе
			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);
		Конецесли;
		Если ИсточникКолонка= неопределено тогда
			//недостаточно реквизитов
			Если ФормироватьОтстутствующиеКолонки тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			Иначе
				Возврат Неопределено;
			КонецЕсли;	
		Иначе
			НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
		Конецесли;
	КонецЦикла;
	
    Возврат НоваяТЗ;
КонецФункции // СформироватьТаблицуОплаты()

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт

	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата", ДокументОбъект.Дата);
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	Для каждого Реквизит из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;
	СтруктураШапкиДокумента.Вставить("ВидДокумента", МетаданныеДокумента.Имя);
	СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", СокрЛП(ДокументОбъект));

	СтруктураШапкиДокумента.Вставить("ОрганизацияНеЯвляетсяПлательщикомНДС", Ложь);
	Если СтруктураШапкиДокумента.Свойство("Организация") Тогда
		СтруктураПолейУчетнойПолитикиНУ = Новый Структура("ОрганизацияНеЯвляетсяПлательщикомНДС");
		ДополнитьПоложениямиУчетнойПолитики(СтруктураШапкиДокумента, СтруктураШапкиДокумента.Дата, , СтруктураШапкиДокумента.Организация, "Нал", СтруктураПолейУчетнойПолитикиНУ);
	КонецЕсли;

	СтруктураШапкиДокумента.Вставить("ВедетсяУчетНДСПоФЗ134", УчетНДС.ВедетсяУчетНДСПоФЗ134(СтруктураШапкиДокумента.Дата));
	
	Возврат СтруктураШапкиДокумента;

КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено, ЗаполнитьПериод = истина) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРек.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;
	
	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());
	ЕстьПериод    = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;
	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;
		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ?(ИмяКолонки = "ВидДвижения", ВидДвижения = Неопределено, Истина)
		   И ИмяКолонки <> "МоментВремени" Тогда
		   
			Если ИзмеренияСостТипа.Свойство(ИмяКолонки) Тогда
				ФлагКолонкиСостТипа = Истина;
			Иначе
				ФлагКолонкиСостТипа = Ложь;
			КонецЕсли;
			
			Индекс = 0;
			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда
					
					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;
					
					МассивСтрок[Индекс] = СтрокаДвижения;
					СтрокаДвижения.Период = НаборДвижений.мПериод;
					Если не ЗаполнитьПериод и ЕстьПериод И НЕ СтрокаТаблицы.Период = '00010101' Тогда
						СтрокаДвижения.Период = СтрокаТаблицы.Период;
					Иначе
						СтрокаДвижения.Период = НаборДвижений.мПериод;
					КонецЕсли; 
					
				Иначе
					
					СтрокаДвижения = МассивСтрок[Индекс];
					
				КонецЕсли;
				
				Индекс = Индекс + 1;
				
				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда

					Очистить = Ложь;
					Если ТипЗнч(ЗначКолонки) = Тип("Число")Тогда
						Если ЗначКолонки = 0 Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Строка") Тогда
						Если ЗначКолонки = "" Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Дата") Тогда
						Если ЗначКолонки = '00010101000000' Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ЗначКолонки = Неопределено Или ЗначКолонки.Пустая() Тогда
						Очистить = Истина;
					КонецЕсли;

					Если Очистить Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;
				
			КонецЦикла;
			
			ПерваяКолонка = Ложь;
			
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Процедура сворачивает движения по регистру накопления
//
Процедура СвернутьТаблицуДвиженийРегистраНакопления(НаборДвижений, ТабДвижений = Неопределено, УдалятьПустыеДвижения = Ложь) Экспорт
	
	Если ТипЗнч(НаборДвижений) = Тип("Строка") Тогда
		МетаРег = Метаданные.РегистрыНакопления[НаборДвижений];
		ТаблицаДвижений = ТабДвижений;
	Иначе
		МетаРег = НаборДвижений.Метаданные();
		Если ТабДвижений = Неопределено Тогда
			ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
		Иначе
			ТаблицаДвижений = ТабДвижений;
		КонецЕсли;
	КонецЕсли;
	
	
	Если ТаблицаДвижений = Неопределено ИЛИ ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Измерения = "Период,Регистратор,Активность";
	Если МетаРег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
		Измерения = Измерения + ",ВидДвижения";
	КонецЕсли;
	
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	
	Ресурсы = "";
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Ресурсы = Ресурсы + МетаРес.Имя + ",";
	КонецЦикла;
	
	ТаблицаДвижений.Свернуть(Измерения, Ресурсы);
	
	Если УдалятьПустыеДвижения Тогда
		
		СтруктРесурсы   = Новый Структура(Ресурсы);
		МассивПустСтрок = Новый Массив;
		СтруктПоиска    = Новый Структура;
		
		Для Каждого РесурсКлюч Из СтруктРесурсы Цикл
			СтруктПоиска.Вставить( РесурсКлюч.Ключ, 0);
		КонецЦикла;
		
		МассивПустСтрок = ТаблицаДвижений.НайтиСтроки(СтруктПоиска);
		Для К = 0 По МассивПустСтрок.ВГраница() Цикл
			ТаблицаДвижений.Удалить(МассивПустСтрок[К]);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры // СвернутьТаблицуДвиженийРегистраНакопления()

// Получить движение(набор записей) для документа-объекта
//
// Параметры
//  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
//  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей   – набор записей для объекта
//
Функция ПолучитьДвижение(Объект, ТипДвижения, Сообщать=Ложь) Экспорт
	Движение = неопределено;
	Для каждого ТекДвижение из Объект.Движения цикл
		Если ТипЗнч(ТипДвижения.СоздатьНаборЗаписей()) = ТипЗнч(ТекДвижение) тогда
			Движение=ТекДвижение;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Сообщать и Движение = неопределено тогда
		СообщитьОбОшибке("Требуется подключение """+ТипЗНЧ(Объект)+""" к формированиям движения по регистру """+ТипЗнч(ТипДвижения)+"""!");
	КонецЕсли;
	Возврат Движение;
КонецФункции // ПолучитьДвижение()

// Получить набор записей по регистру по ссылке на документ
//
// Параметры
//  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
//  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
//  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
//	 Неопределено 				в случае если документ не может формировать движений по регистру.
//
Функция ПолучитьНаборЗаписейПоСсылке(Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь) Экспорт
	Движения = неопределено;
	Если Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения))) тогда
        Движения = РегистрДвижения.СоздатьНаборЗаписей();
		Движения.Отбор.Регистратор.Установить(Ссылка);
		Если ПрочитатьЗаписи тогда
			Движения.Прочитать();
		КонецЕсли;
	ИначеЕсли Сообщать тогда
			СообщитьОбОшибке("Требуется подключение документа """+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Представление()+""" к формированию движений по регистру """+
			СтрЗаменить(Лев(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":"))," менеджер","")+Сред(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":")+1)+
			"""!");
	КонецЕсли;
	
	Возврат Движения;
КонецФункции // ПолучитьДвижение()

// Процедура удаляет строки с пустыми значениями из структуры таблиц документа
//	Параметры:
//		- ТаблицыДляДвиженийПоЗаказам - структура таблиц документа
//		- ИмяПоля - имя поля, значение которого проверяет на пустое значение.
//
Процедура УдалитьСтрокиИзТаблицДокумента(ТаблицыДляДвиженийПоЗаказам, ИмяПоля) Экспорт

	Для Каждого ТабЧасть Из ТаблицыДляДвиженийПоЗаказам Цикл
		КолвоСтрок = ТабЧасть.Значение.Количество();
		Для Инд = 1 По КолвоСтрок Цикл
			ТекСтрока = ТабЧасть.Значение[КолвоСтрок - Инд];

			Если НЕ ЗначениеЗаполнено(ТекСтрока[ИмяПоля]) Тогда
				ТабЧасть.Значение.Удалить(ТекСтрока);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры // УдалитьСтрокиИзТаблицДокумента()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОЧИХ ПОДСИСТЕМ, НЕ ИМЕЮЩИХ СВОИХ ОБЩИХ МОДУЛЕЙ

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(НЕ ЗначениеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(НЕ ЗначениеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()

// Возвращает рабочую дату
//
// Возвращаемое значение:
//   Дата - рабочая дата
//
Функция ПолучитьРабочуюДату() Экспорт

#Если Клиент Тогда
	Дата = РабочаяДата;
#Иначе
	Дата = ТекущаяДата();
#КонецЕсли

	Возврат Дата;

КонецФункции // ПолучитьРабочуюДату()

// Возвращает строку, описывающую период, определяемый переданными
// датой и периодичностью.
//
// Параметры
//  ДатаВПериоде:Дата - дата из периода
//  Периодичность: Строка - строка, определяющая периодичность
//
// Возвращаемое значение:
//   СтрокаПериод: строка   – представление периода для вывода в отчетах
//
Функция ПолучитьПериодСтрокой(ДатаВПериоде,Периодичность) Экспорт

	Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ = ""гггг """"г.""""""";
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ = ""к"""" квартал"""" гггг """"г.""""""";
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ = ""ММММ гггг """"г.""""""";
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ = """"""Неделя с"""" дд.ММ.гггг """"""";
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ = ""дд.ММ.гггг """"г.""""""";
	Иначе
		ФорматДаты = "";
	КонецЕсли;

	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
		СтрокаПериод = СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ = """""" по """" дд.ММ.гггг """"г.""""""");
	КонецЕсли;
	
	Возврат СтрокаПериод;
	
КонецФункции // ПолучитьПериодСтрокой()

// Функция возвращает структуру с параметрами учетной политики (налоговый учет)
//
Функция ПолучитьПараметрыУчетнойПолитикиНалоговыйУчет(Знач КонДата, Отказ,Организация) Экспорт

	СтруктураУчПолитика = Новый Структура;
	Если НЕ ЗначениеЗаполнено(Организация) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;
		
	ИначеЕсли НЕ ЗначениеЗаполнено(КонДата) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	УчетнаяПолитикаСрезПоследних.*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитикаНалоговыйУчет.СрезПоследних(&КонДата, Организация = &Организация) КАК УчетнаяПолитикаСрезПоследних";	

	Запрос.УстановитьПараметр("КонДата", КонДата);
	Запрос.УстановитьПараметр("Организация", Организация);
	РезультатЗапроса = Запрос.Выполнить();

	Если РезультатЗапроса.Пустой() Тогда
		СообщитьОбОшибке("Не заполнен регистр сведений ""Учетная политика (налоговый учет)"" для организации """+Организация+"""на " + Формат(КонДата, "ДЛФ=DD"), Отказ);

	Иначе

		РезультатЗапроса = РезультатЗапроса.Выгрузить();

		Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
			Если КонДата>= '20060101' И Колонка.Имя = "МоментОпределенияНалоговойБазыНДС" И РезультатЗапроса[0][Колонка.Имя] = Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОплате Тогда
				СтруктураУчПолитика.Вставить(Колонка.Имя, Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОтгрузке);
			Иначе 
				СтруктураУчПолитика.Вставить(Колонка.Имя, РезультатЗапроса[0][Колонка.Имя]);
			КонецЕсли;
			Если КонДата >= '20080101' И Колонка.Имя = "НДСНалоговыйПериод" И РезультатЗапроса[0][Колонка.Имя] = Перечисления.Периодичность.Месяц Тогда
				СтруктураУчПолитика.Вставить(Колонка.Имя, Перечисления.Периодичность.Квартал);
			Иначе 
				СтруктураУчПолитика.Вставить(Колонка.Имя, РезультатЗапроса[0][Колонка.Имя]);
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;

	Возврат СтруктураУчПолитика;

КонецФункции // ПолучитьПараметрыУчетнойПолитикиНалоговыйУчет()

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//  ИсхСумма   - распределяемая сумма
//  МассивКоэф - массив коэффициентов распределения
//  Точность   - точность округления при распределении. Необязателен.
//
//Возвращает:
//  МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//               суммы в соответствии с весом коэффициента (из массива коэффициентов)
//               В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//               или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина) Экспорт

	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		
		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);
		
		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;
		
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[К];
	КонецЦикла;
	
	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;
	
	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено, ПечатьПрефиксовРИБ = Истина) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	ПечатьПрефиксовРИБ = ОбщегоНазначения.ПолучитьЗначениеПеременной("ПечатьПрефиксаРИБ") И ПечатьПрефиксовРИБ;

	Номер   = СокрЛП(Документ.Номер);
	Префикс = "";

	Если ПечатьПрефиксовРИБ Тогда
		МассивПрефиксовРИБ = ПолучитьМассивПрефиксовРИБ();
		Если МассивПрефиксов = Неопределено Тогда
			Организация = Неопределено;
			Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
				ИЛИ ТипЗнч(Документ) = Тип("Структура") Тогда
				Организация = Документ.Организация;
			Иначе
				МетаданныеДокумента = Документ.Метаданные();
				Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда
					Организация = Документ.Организация;
				КонецЕсли;
			КонецЕсли;
			МассивПрефиксовДляОбхода = СформироватьМассивПрефиксовПоОрганизации(Организация);
		Иначе
			МассивПрефиксовДляОбхода = Новый Массив;
			Для каждого ПрефиксИзМассива Из МассивПрефиксов цикл
				Если МассивПрефиксовРИБ.Найти(ПрефиксИзМассива) = Неопределено 
					И МассивПрефиксовДляОбхода.Найти(ПрефиксИзМассива) = Неопределено Тогда
					МассивПрефиксовДляОбхода.Добавить(ПрефиксИзМассива);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		ПрефиксРИБ = "";
		Для каждого ПрефиксРИБИзМассива Из МассивПрефиксовРИБ Цикл
			Если Найти(Номер, ПрефиксРИБИзМассива)=1 Тогда 
				Номер = Сред(Номер, СтрДлина(ПрефиксРИБИзМассива)+1);
				ПрефиксРИБ = ПрефиксРИБ + ПрефиксРИБИзМассива;
			КонецЕсли;
		КонецЦикла;
	Иначе
		Если МассивПрефиксов = Неопределено Тогда
			Организация = Неопределено;
			Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
				ИЛИ ТипЗнч(Документ) = Тип("Структура") Тогда
				Организация = Документ.Организация;
			Иначе
				МетаданныеДокумента = Документ.Метаданные();
				Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда
					Организация = Документ.Организация;
				КонецЕсли;
			КонецЕсли;
			МассивПрефиксовДляОбхода = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация)
		Иначе
			МассивПрефиксовДляОбхода = МассивПрефиксов;
		КонецЕсли;
	КонецЕсли;
	Для Каждого ТекущийПрефикс ИЗ МассивПрефиксовДляОбхода Цикл
		// удаление префикса из номера документа
		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;

	Если ПечатьПрефиксовРИБ И ПрефиксРИБ <> "" Тогда
		Номер = ПрефиксРИБ + Номер;
	КонецЕсли;

	Возврат Номер;

КонецФункции // ПолучитьНомерНаПечать()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

#Если Клиент Тогда
// Производит проверку наличия комплекта обновления и 
// открывает форму для просмотра результатов проверки
//Процедура ПроверкаНаличияКомплектаОбновлений() Экспорт

//	Обозреватель = Обработки.Обозреватель.Создать();
//	Форма        = Обозреватель.ПолучитьФорму("ПроверкаНаличияОбновления");

//	Обозреватель.Проверить(Форма.ЭлементыФормы);

//	Форма.Открыть();

//КонецПроцедуры

// Позволяет просматривать веб-страницы в обработке Обозреватель  
//
// Параметры
//  АдресСтраницы  – Строка – адрес просматриваемой страницы
//
// Если передается пустая строка, то в обработке Обозреватель 
// просматривается веб-страница конфигурации
// 
Процедура ПоказатьВебСтраницу(АдресСтраницы) Экспорт

	Обозреватель = Обработки.Обозреватель.Создать();
	
	Форма = Обозреватель.ПолучитьФорму();
	Форма.СтартоваяСтраница = АдресСтраницы;
	
	Форма.Открыть();

КонецПроцедуры

// Позволяет просматривать веб-страницу http://v8.1c.ru/lawmonitor/ в обработке Обозреватель  
//
Процедура МониторингЗаконодательства() Экспорт
	ПоказатьВебСтраницу("http://v8.1c.ru/lawmonitor/");
КонецПроцедуры

// Процедура выполняет открытие HTML-страницы 
// по указанному URL
Процедура Интерфейс1Действие() Экспорт
	Форма = Обработки.Обозреватель.ПолучитьФорму("Форма",,"Опрос");
	Форма.Заголовок = "Отзыв о программе";
	Форма.СтартоваяСтраница = "www.1c.ru/usability/inquirer/ut.jsp";
	Форма.Открыть();
КонецПроцедуры

#КонецЕсли

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра

	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
	КонецЕсли; 
	ТаблицаДанных.Индексы.Добавить("ИмяРаздела");
	
	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;
	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
		
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
		Если СтрокаРаздела = Неопределено Тогда
			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Попытка
			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли; 
		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;
		МассивЗначений.Добавить("");
		
		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
		
	КонецЦикла;
	
	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
	
КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============= Сведения об использовании ПП 1С:Предприятие 8 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8: "   + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если НЕ ЗначениеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
		
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ

// Функция возвращает значение экспортных переменных модуля приложений из параметра сеанса
// Необходмо для возможности создания объектов на сервере
Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	// Значение в КЭШе не нашли, получим значение из БД
	Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
		НайденноеЗначение = ПараметрыСеанса.ТекущийПользователь;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глСоответствиеТекстовЭлектронныхПисем") Тогда
		НайденноеЗначение = Новый Соответствие;				
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетнаяПолитикаПоУправленческомуУчету") Тогда
		НайденноеЗначение = СоздатьКЭШУчетнойПолитики("");
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетнаяПолитикаПоНалоговомуУчету") Тогда
		НайденноеЗначение = СоздатьКЭШУчетнойПолитики("НалоговыйУчет");
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВалютаРегламентированногоУчета") Тогда
		НайденноеЗначение = Константы.ВалютаРегламентированногоУчета.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВалютаУправленческогоУчета") Тогда
		НайденноеЗначение = Константы.ВалютаУправленческогоУчета.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ИспользоватьСерииНоменклатуры") Тогда
		НайденноеЗначение = Константы.ИспользоватьСерииНоменклатуры.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ИспользоватьХарактеристикиНоменклатуры") Тогда
		НайденноеЗначение = Константы.ИспользоватьХарактеристикиНоменклатуры.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ИспользоватьВозвратнуюТару") Тогда
		НайденноеЗначение = Константы.ИспользоватьВозвратнуюТару.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("УказаниеСкладовВТабличнойЧастиДокументов") Тогда
		НайденноеЗначение = Константы.УказаниеСкладовВТабличнойЧастиДокументов.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ИспользоватьОплатуБанковскимиКредитами") Тогда
		НайденноеЗначение = Константы.ИспользоватьОплатуБанковскимиКредитами.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ИспользоватьОплатуПлатежнымиКартами") Тогда
		НайденноеЗначение = Константы.ИспользоватьОплатуПлатежнымиКартами.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ПечатьПрефиксаРИБ") Тогда
		НайденноеЗначение = Константы.ПечатьПрефиксаРИБ.Получить();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоОбменДанными") Тогда
		НайденноеЗначение = ПроцедурыОбменаДанными.ВыполнитьИнициализациюАвтообменаПриНачалеРаботы();
		
	#Если Клиент Тогда

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоПолученияОтправкиЭлектронныхПисем") Тогда	
		Если ПравоДоступа("Использование", Метаданные.Обработки.АвтоПолучениеОтправкаЭлектронныхПисем) Тогда
			НайденноеЗначение = Обработки.АвтоПолучениеОтправкаЭлектронныхПисем.ПолучитьФорму();
		Иначе
			НайденноеЗначение = Неопределено;
		КонецЕсли;

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("КэшСтратегииАвтонумерации") Тогда	
		НайденноеЗначение = Новый Соответствие;		
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ФормаОповещенияОЗадачах") Тогда	
		НайденноеЗначение = Задачи.ЗадачиПользователя.ПолучитьФорму("ФормаОповещенияОЗадачах", ,"Оригинал");
		
	#КонецЕсли

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глКоличествоСекундОпросаОбмена") Тогда
		НайденноеЗначение = Константы.ИнтервалДляОпросаРегламентныхЗаданийВФайловомВарианте.Получить();
		Если НайденноеЗначение = 0 Тогда
			НайденноеЗначение = 60;
		КонецЕсли;
				
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ЗначенияНастроекПользователей") Тогда
		НайденноеЗначение = Новый Соответствие;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ЗначенияДополнительныхПравПользователя") Тогда
		НайденноеЗначение = Новый Соответствие;
	
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("НомерВерсииКонфигурации") Тогда
		НайденноеЗначение = ОбновлениеИнформационнойБазы.ВерсияИБ(Метаданные.Имя);
		
	Иначе
		НайденноеЗначение = Константы[ВРег(ИмяПараметра)].Получить();
		
		//СтрокаИсключения = "Невозможно обработать параметр " + """" + ИмяПараметра + """" + " для получения значения";
		//ВызватьИсключение СтрокаИсключения;
	КонецЕсли;
	
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции

Процедура УстановитьЗначениеПеременной(ИмяПараметра, Кэш, ЗначениеПараметра, ОбновлятьВоВсехКэшах = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	КонецЕсли;
	
	Если Кэш.Свойство(ИмяПараметра) Тогда
		Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
	КонецЕсли;
	
	#Если Клиент ИЛИ ВнешнееСоединение Тогда
		Если ОбновлятьВоВсехКэшах Тогда
			КэшНаСервере = ПараметрыСеанса.ОбщиеЗначения.Получить();
			КэшНаСервере.Вставить(ИмяПараметра, ЗначениеПараметра);
			ПараметрыСеанса.ОбщиеЗначения = Новый ХранилищеЗначения(КэшНаСервере);
		КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры

Функция ПолучитьОсновнойДоговорКонтрагента(Контрагент) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	ДоговорыКонтрагентов.Ссылка КАК ДоступныйДоговорКонтрагента,
	|	ДоговорыКонтрагентов.Наименование КАК ДоступныйДоговорКонтрагентаНаименование
	|ИЗ
	|	Справочник.ДоговорыКонтрагентов КАК ДоговорыКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновнойДоговорКонтрагента = ДоговорыКонтрагентов.Ссылка
	|ГДЕ
	|	ДоговорыКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновнойДоговорКонтрагента ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ДоступныйДоговорКонтрагента;		
	Иначе
		Возврат Справочники.ДоговорыКонтрагентов.ПустаяСсылка();		
	КонецЕсли;	
		
КонецФункции

Функция ПолучитьОсновноеКонтактноеЛицоКонтрагента(Контрагент) Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	КонтактныеЛицаКонтрагентов.Ссылка КАК ДоступноеКонтактноеЛицоКонтрагента
	|ИЗ
	|	Справочник.КонтактныеЛицаКонтрагентов КАК КонтактныеЛицаКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновноеКонтактноеЛицо = КонтактныеЛицаКонтрагентов.Ссылка
	|ГДЕ
	|	КонтактныеЛицаКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновноеКонтактноеЛицо ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";

	Запрос.УстановитьПараметр("Контрагент", Контрагент);

	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ДоступноеКонтактноеЛицоКонтрагента;		
	Иначе
		Возврат Справочники.КонтактныеЛицаКонтрагентов.ПустаяСсылка();		
	КонецЕсли;	

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

Процедура УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, ПроверятьДвижения = Ложь)Экспорт
	// получение списка последовательностей в которых зарегистрирован документ
	Если ПроверятьДвижения Тогда
		ТаблицаРегистраций = ОпределитьНаличиеРегистрацииДокументаВПоследовательности(ДокументОбъект);
	КонецЕсли;      
	КоллекцияПоследовательностей = ДокументОбъект.ПринадлежностьПоследовательностям;
	Для Каждого НаборЗаписейРегистрацииВПоследовательности ИЗ КоллекцияПоследовательностей Цикл
		Если (НаборЗаписейРегистрацииВПоследовательности.Количество() > 0)
		  ИЛИ (ПроверятьДвижения И (НЕ ТаблицаРегистраций.Найти(НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя,"Имя") = Неопределено)) Тогда
		   НаборЗаписейРегистрацииВПоследовательности.Очистить();
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры//УдалитьРегистрациюДокументаВПоследовательностях

Функция ОпределитьНаличиеРегистрацииДокументаВПоследовательности(ДокументОбъект) Экспорт
	ТекстЗапроса = "";	
	
	Для Каждого Последовательность ИЗ ДокументОбъект.ПринадлежностьПоследовательностям Цикл
		// в запросе получаем имена последовательностей, в которых документ зарегистрирован
		ТекстЗапроса = ТекстЗапроса + "
		|" + ?(ТекстЗапроса = "", "", "ОБЪЕДИНИТЬ ВСЕ ") + "
		|ВЫБРАТЬ """ + Последовательность.Метаданные().Имя 
		+  """ КАК Имя ИЗ " + Последовательность.Метаданные().ПолноеИмя()  
		+ " ГДЕ Регистратор = &Регистратор";
		
	КонецЦикла;
	
	Если ТекстЗапроса = "" Тогда
		Возврат Новый ТаблицаЗначений();
	Иначе
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Регистратор", ДокументОбъект.Ссылка);
		ТаблицаЗапроса = Запрос.Выполнить().Выгрузить();	
		Возврат ТаблицаЗапроса;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	Если ПараметрыСеанса.ИспользованиеРИБ 
		ИЛИ ПараметрыСеанса.НаличиеОбменаТорговляБухгалтерия 
		ИЛИ ПараметрыСеанса.НаличиеОбменаТорговляБухгалтерияКОРП
		ИЛИ ПараметрыСеанса.НаличиеОбменаСРозничнойТорговлей 
		ИЛИ ОбменДаннымиПовтИсп.ОбменДаннымиВключен() Тогда
		
		Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура СообщитьИнформацияОПрефиксации() Экспорт
	
	Если ПустаяСтрока(ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы) Тогда
		
		Сообщить("Для задействования механизма установки префиксов объектов необходимо установить константу ""Префикс узла для распределенной информационной базы"" 
			| и перезапустить текущий сеанс работы 1С:Предприятия.");
		Сообщить("Текущее значение префикса: " + ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы);
		
	КонецЕсли;
	
КонецПроцедуры

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции

// РАБОТА С ПЕРЕМЕННЫМИ

// Меняет местами значения двух доступных для записи переменных
//
// Параметры
//  Источник - первая переменная
//  Приемник – вторая переменная
//
Процедура ПоменятьПеременныеМестами(Источник, Приемник) Экспорт

	тмп = Источник;
	Источник = Приемник;
	Приемник = Тмп;

КонецПроцедуры // ПоменятьПеременныеМестами()

// Отбирает из переданной таблицы строки по заданным критериям.
//
// Параметры:
//  Источник - ТаблицаЗначений, РезультатЗапроса, ОбластьЯчеекТабличногоДокумента. Таблица-источник.
//  СтруктураКритериев - Структура. Названия отборов и значения, по которым нужно отобрать строки.
//  СтруктураСложныхКритериев - Структура. Если свойство передано, то значение содержит вид сравнения.
//
// Возвращаемое значение:
//  РезультатЗапроса - таблица с нужными строками.
//
Функция ОтобратьСтрокиПоКритериям(Источник, СтруктураКритериев, СтруктураСложныхКритериев = Неопределено) Экспорт

	Перем ВидСравненияСложный;

	Если СтруктураСложныхКритериев = Неопределено Тогда
		СтруктураСложныхКритериев = Новый Структура;
	КонецЕсли;

	ПостроительЗапроса = Новый ПостроительЗапроса;
	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник);

	Для Каждого Критерий Из СтруктураКритериев Цикл
		НовыйОтбор = ПостроительЗапроса.Отбор.Добавить(Критерий.Ключ);

		СтруктураСложныхКритериев.Свойство(Критерий.Ключ, ВидСравненияСложный);

		Если ВидСравненияСложный = Неопределено Тогда
			НовыйОтбор.Установить(Критерий.Значение);
		Иначе
			НовыйОтбор.Использование = Истина;
			НовыйОтбор.ВидСравнения = ВидСравненияСложный;
			НовыйОтбор.Значение = Критерий.Значение;
		КонецЕсли;
	КонецЦикла;

	Возврат ПостроительЗапроса.Результат;

КонецФункции // ОтобратьСтрокиПоКритериям()

// Возвращает дату начала периода по имеющимся данным о:
// дате окончании периода, значении перечисления Период, количестве периодов.
// Кроме того, в случае, если задать отрицательную периодичность,- функция возвратит
// дату окончания периода по заданной дате начала периода
Функция ПолучитьДатуНачалаПериодаПоДатеОкончанияКоличествуПериодов(ДатаОкончания, ПериодСсылка, КоличествоПериодов) Экспорт
	
	Если КоличествоПериодов = 0 Тогда
		КоличествоПериодов = 1;
	КонецЕсли;
	
	Если ДатаОкончания = Неопределено Тогда
		
		Если КоличествоПериодов > 0 Тогда
			ДатаОкончания = КонецДня(ТекущаяДата());
		ИначеЕсли КоличествоПериодов < 0 Тогда
			ДатаОкончания = НачалоДня(ТекущаяДата());
		КонецЕсли;
		
	КонецЕсли;
	
	Если (ПериодСсылка = Перечисления.Периодичность.День) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Неделя) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24*7 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Декада) Тогда
		ДеньМесяца = День(ДатаОкончания);
		НачМесяца = НачалоМесяца(ДатаОкончания);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;
		
		НомерДекады = НомерДекады - КоличествоПериодов + ?(КоличествоПериодов > 0, 1 , -1);
		Если НомерДекады > 0 Тогда
			Месяцев = Цел((НомерДекады-1)/3);
		Иначе
			Месяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;
		
		НомерДекады = НомерДекады - 3*Месяцев;
		Дт = ДобавитьМесяц(НачМесяца, Месяцев) + (НомерДекады-1) * 10 * 24 * 60 * 60;
		
		Возврат ?(КоличествоПериодов>0, Дт, ПолучитьКонецДекады(Дт));
		
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Месяц) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Квартал) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(3 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Полугодие) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(6 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Год) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(12 * КоличествоПериодов)));
	КонецЕсли;
	
	Если КоличествоПериодов > 0 Тогда
		Возврат ДатаНачала + 60*60*24;
	ИначеЕсли КоличествоПериодов < 0 Тогда
		Возврат КонецДня(ДатаНачала - 60*60*24);
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА

// Вспомогательная функция для определнения условий запроса в механизме
// изменения порядка следования элементов. Ставит условия на родителя и владельца
//
// Параметры
//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
//  Запрос - Запрос, в который дописываем условия
// 
//  Возвращаемое значение:
//   Строка - условие запроса
// 
Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)

	ТекстЗапроса = "";
	
	Если Элемент.Метаданные().Иерархический = Истина Тогда
		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
		Если НЕ БезПервогоИ Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";
	КонецЕсли; 
	
	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";
	КонецЕсли; 

	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает значение порядка для нового элемента справочника.
//
// Параметры
//  ЭлементОбъект - СправочникОбъект - новый объект
//
// Возвращаемое значение:
//   Число - новый порядок
//
Функция НазначитьНовыйПорядок(ЭлементОбъект)

	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
	
	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
	
	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";
	КонецЕсли; 
	
	Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат (Выборка.Порядок + 1)
	КонецЕсли; 

КонецФункции

// Процедура вызывается перед записью объекта, для которого необходимо
// контролировать порядок элементов.
// 
// Параметры
//  Отказ - Булево, отказ от записи объекта
//  ЭтотОбъект - СправочникОбъект
//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
//
Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт

	Если ЭтотОбъект.ЭтоНовый() Тогда
		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
	Иначе
		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
		КонецЕсли;
	КонецЕсли;
	
	Если КонтролироватьПорядок Тогда
	
		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";
		
		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
			Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Отказ = Истина;
			#Если Клиент Тогда
				Сообщить("Не уникальный порядок элемента справочника.");
			#КонецЕсли
		КонецЕсли;
	
	КонецЕсли; 

КонецПроцедуры

// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
// порядком следования.
// 
// Параметры:
//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
Процедура ИзменитьПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина) Экспорт
	
	ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
	
	Если ЭлементЗамены = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
	НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
	
	Если НаправлениеПорядка = "Вверх" Тогда
		Если НовыйПорядокЗамены < НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены + 1;
		КонецЕсли; 
	Иначе
		Если НовыйПорядокЗамены > НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены - 1;
		КонецЕсли;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	ФиксироватьТранзакцию = Истина;
	
	Если НовыйПорядокЗамены <> ЭлементЗамены.Порядок Тогда
		ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
		ОбъектЗамены.Порядок = НовыйПорядокЗамены;
		ОбъектЗамены.КонтролироватьПорядок = Ложь;
		Попытка
			ОбъектЗамены.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли; 
	
	Если ФиксироватьТранзакцию Тогда
		ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
		ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
		Попытка
			ОбъектЭлемента.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если ФиксироватьТранзакцию Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли; 
	
КонецПроцедуры

// Функция определяет элемент справочника, с которым необходимо
// произвести "рокировку" текущего элемента
//
// Параметры
//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
// Возвращаемое значение:
//   СправочникСсылка
//
Функция ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг)

	ТекущийПорядок = ЭлементСсылка.Порядок;
	
	ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
		
	ИначеЕсли ЦиклическийСдвиг Тогда
		// Текущий элемент или первый (при движении вверх)
		// или последний (при движении вниз)
		// или вообще единственный
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Ссылка
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", ">", "<") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
		|УПОРЯДОЧИТЬ ПО
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
		|";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Неопределено;
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Возврат Выборка.Ссылка;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML

// Функция осуществляет построение дерева XML.
//
// Параметры
//  XML             - <ЧтениеXML>
//                  - Объект, при помощи которого осуществляется чтение
//                    файла отчета.
//
//  Дерево          - <Структура>
//                  - Дерево XML.
//
//  ПервыйВызов     - <Булево>
//                  - Служебный параметр.
//
// Возвращаемое значение:
//  <Булево>        - Результат выполнения.
//
Функция ПостроитьДеревоXML(XML, Дерево, ПервыйВызов = Истина) Экспорт

	Результат = Истина;
	Имя       = "";
	Врем      = Неопределено;
	Врем2     = Неопределено;
	Врем3     = Неопределено;

	Если ПервыйВызов Тогда
		Дерево = Новый Структура();
	КонецЕсли;

	Если XML.Прочитать() Тогда
		Если XML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Имя  = XML.ЛокальноеИмя;
			Врем = Новый Структура();
			Пока ПостроитьДеревоXML(XML, Врем, Ложь) Цикл
			КонецЦикла;
			Пока XML.Имя <> Имя Цикл
				Если XML.ТипУзла = ТипУзлаXML.Текст Тогда
					Врем = XML.Значение;
				КонецЕсли;
				Если Не XML.Прочитать() Тогда
					Результат = Ложь;
					Возврат Результат;
				КонецЕсли;
			КонецЦикла;
			Дерево.Свойство(Имя, Врем2);
			Если Врем2 = Неопределено Тогда
				Врем2 = Врем;
			Иначе
				Если ТипЗнч(Врем2) = Тип("Массив") Тогда
					Врем2.Добавить(Врем);
				Иначе
					Врем3 = Новый Массив();
					Врем3.Добавить(Врем2);
					Врем3.Добавить(Врем);
					Врем2 = Врем3;
				КонецЕсли;
			КонецЕсли;
			Дерево.Вставить(Имя, Врем2);
		Иначе
			Результат = Ложь;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПостроитьДеревоXML()

// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УЧЕТНОЙ ПОЛИТИКОЙ

// Функция применяется при необходимости получить сведения об учетной политике организации.
//
// Параметры:
// Учет - строка. Определяет регистр сведений, из которого будут получены данные:
//   "НалоговыйУчет" или "БухгалтерскийУчет".
//
// Возвращаемое значение - таблица значений. Таблица, каждая строка которой 
//  соответствует записи регистра. 
//
Функция СоздатьКЭШУчетнойПолитики(Учет) Экспорт

	Запрос = Новый Запрос("
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитика" + Учет + "
	|УПОРЯДОЧИТЬ ПО
	|	Период
	|");

	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции // СоздатьКЭШУчетнойПолитики()

// Функция возвращает структуру с параметрами учетной политики на заданную дату.
//
Функция ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация = Неопределено, Учет = "Упр", СообщатьОбОшибке = Истина) Экспорт
	
	СтруктураУчПолитика = Новый Структура;
			
	Если Учет <> "Упр" И НЕ ЗначениеЗаполнено(Организация) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;
		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(КонДата) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;

	Если Учет = "Нал" Тогда		
		УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаПоНалоговомуУчету");		
	ИначеЕсли Учет = "Упр" Тогда
		УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаПоУправленческомуУчету");
	КонецЕсли; 
		
	Если Учет = "Упр" Тогда
		
		Если УчетнаяПолитика.Количество() = 0 Тогда
			Отказ = Истина;
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Не указаны параметры учетной политики управленческого учета на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			КонецЕсли;	
			Возврат СтруктураУчПолитика;	
		Иначе
				
			Номер = 0;
			ФлагОтказа = Истина;
			Для НомерСтроки = 1 По УчетнаяПолитика.Количество() Цикл
					
				Строка = УчетнаяПолитика.Получить(НомерСтроки - 1);
				Если Строка.Период <= КонДата Тогда
					Номер = НомерСтроки;
					ФлагОтказа = Ложь;
						
				Иначе 
					Прервать;
				КонецЕсли;
			КонецЦикла;
				
			Если Номер <> 0 Тогда
				Строка = УчетнаяПолитика.Получить(Номер - 1);
				Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
					СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
				КонецЦикла;
					
			КонецЕсли;
				
		КонецЕсли;
		
	Иначе
		
		УчетнаяПолитикаОрганизации = УчетнаяПолитика.НайтиСтроки(Новый Структура("Организация", Организация));
		
		Если УчетнаяПолитикаОрганизации.Количество() = 0 Тогда
			Отказ = Истина;
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Не указаны параметры учетной политики налогового учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			КонецЕсли;	
			Возврат СтруктураУчПолитика;	
		Иначе
				
			Номер = 0;
			ФлагОтказа = Истина;
			Для НомерСтроки = 1 По УчетнаяПолитикаОрганизации.Количество() Цикл
					
				Строка = УчетнаяПолитикаОрганизации.Получить(НомерСтроки - 1);
				Если Строка.Период <= КонДата Тогда
					Номер = НомерСтроки;
					ФлагОтказа = Ложь;
						
				Иначе 
					Прервать;
				КонецЕсли;
			КонецЦикла;
				
			Если Номер <> 0 Тогда
				Строка = УчетнаяПолитикаОрганизации.Получить(Номер - 1);
				Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
					СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
				КонецЦикла;
				Если КонДата>= '20060101' и СтруктураУчПолитика.Свойство("МоментОпределенияНалоговойБазыНДС") и СтруктураУчПолитика.МоментОпределенияНалоговойБазыНДС = Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОплате Тогда			
					СтруктураУчПолитика.Вставить("МоментОпределенияНалоговойБазыНДС", Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОтгрузке);
				КонецЕсли; 
					
			КонецЕсли;
				
		КонецЕсли;
		
	КонецЕсли;
		
	Если ФлагОтказа = Истина Тогда
		Отказ = Истина;
		Если СообщатьОбОшибке Тогда
			Если Учет = "Упр" Тогда
				СообщитьОбОшибке("Не указаны параметры учетной политики управленческого учета на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			Иначе
				СообщитьОбОшибке("Не указаны параметры учетной политики налогового учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			КонецЕсли;
		КонецЕсли;	
		Возврат СтруктураУчПолитика;
	КонецЕсли; 
		
	Возврат СтруктураУчПолитика;
		
КонецФункции // ПолучитьПараметрыУчетнойПолитики()

// Функция дополняет структуру шапки документа положениями учетной политики.
//
Процедура ДополнитьПоложениямиУчетнойПолитики(СтруктураШапкиДокумента, КонДата, Отказ, Организация, Учет = "Нал", СтруктураПолейУчетнойПолитикиНУ = неопределено) Экспорт
	СтруктураУП = ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация, Учет);
	
	Для каждого ПараметрУП Из СтруктураУП Цикл
		Если (ТипЗнч(СтруктураПолейУчетнойПолитикиНУ) = Тип("Структура"))
		   И НЕ (СтруктураПолейУчетнойПолитикиНУ.Количество() = 0) Тогда
			// Заполнение определенными полями
			Если СтруктураПолейУчетнойПолитикиНУ.Свойство(ПараметрУП.Ключ) Тогда
				Если НЕ ЗначениеЗаполнено(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ]) Тогда
					СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);
				Иначе
					СтруктураШапкиДокумента.Вставить(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ],ПараметрУП.Значение);
				КонецЕсли; 
			КонецЕсли; 
		Иначе	
			// Дополняем всеми параметрами учетной политики
			СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);  
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры // ДополнитьПоложениямиУчетнойПолитики()

// Процедура копирует значения одной строки таблицы значеницй в другую
// структура колонок должна совпадать
//
// Параметры:
//		СтрокаПриемник - строка в которую копируем
//		СтрокаИсточник - строка из которой копируем
//      ИменаКол - имена колонок, разделенные запятыми, которые надо скопировать
//                 необязателен. По умолчанию - все колонки
//
Процедура КопироватьСтрокуТаблицыЗначений(СтрокаПриемник, СтрокаИсточник, ИменаКол) Экспорт

	Если ТипЗнч( ИменаКол) = Тип("ТаблицаЗначений") Тогда
		СписокСвойств = "";
		Для Каждого Кол Из ИменаКол.Колонки Цикл
			Если Не Кол.Имя = "НомерСтроки" Тогда
				Если Не ПустаяСтрока(СписокСвойств) Тогда
					СписокСвойств = СписокСвойств + ",";	
				КонецЕсли;
				СписокСвойств = СписокСвойств + Кол.Имя;
			КонецЕсли;
		КонецЦикла;
		ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, СписокСвойств,);
	Иначе // Строка с именами колонок
        ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, ИменаКол,);
	КонецЕсли;

КонецПроцедуры // КопироватьСтрокуТаблицыЗначений()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ФОРМИРОВАНИЕ КПП НА БАЗЕ ИНН

#Если Клиент Тогда
// Процедура заполняет КПП на базе ИНН
Процедура ЗаполнитьКППпоИНН(Знач ИНН, КПП, БезусловноеЗаполнениеКПП = Истина) Экспорт
	
	// Если КПП формируется стандартным образом по ИНН, то для КПП берутся 
	// первые 4 цифры ИНН + 01001, например:
	// ИНН 7712563009
	// КПП 771201001
		
	// если не указано ИНН или заполнено КПП то прерываем выполнение операции
	Если (СтрДлина(ИНН) < 4) Тогда
		Возврат;
	КонецЕсли;
	
	ПревыеСимволыИНН = Лев(ИНН, 4);
	НовоеЗначениеКПП = ПревыеСимволыИНН + "01001";
	
	// если новое значение КПП и старое значение КПП совпадают, то прерываем выполнение операции
	Если (НовоеЗначениеКПП = КПП) Тогда
		Возврат;
	КонецЕсли;
	
	// если безусловно нужно поменять - меняем
	Если БезусловноеЗаполнениеКПП ИЛИ НЕ ЗначениеЗаполнено(КПП) Тогда
		КПП = НовоеЗначениеКПП;
		Возврат;
	КонецЕсли;
	
	ОтветНужноМенятьКПП = (Вопрос("Изменить КПП автоматически на """ + НовоеЗначениеКПП + """?", РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Да);
	Если ОтветНужноМенятьКПП Тогда
		КПП = НовоеЗначениеКПП;
	КонецЕсли;
	
КонецПроцедуры

#КонецЕсли

//Предназначена для получения массива пустых значений, содержащих значение Неопределено и значения переданного типа или описания типов
Функция МассивПустыхЗначений(ОписаниеТипов) Экспорт
	МассивЗначений = новый Массив;
	МассивЗначений.Добавить(неопределено);
	Если ТипЗнч(ОписаниеТипов)=Тип("ОписаниеТипов") Тогда
		Для каждого Тип из ОписаниеТипов.Типы() Цикл
			МассивЗначений.Добавить(ПустоеЗначениеТипа(Тип));
		КонецЦикла;
	ИначеЕсли ТипЗнч(ОписаниеТипов)=Тип("Тип") Тогда	
		МассивЗначений.Добавить(ПустоеЗначениеТипа(ОписаниеТипов));
	КонецЕсли;
	
	Возврат МассивЗначений;

КонецФункции

// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
// Если такого реквизита нет - возвращается Неопределено.
//
// Параметры:
//  ИмяРеквизита - Строка. Имя искомого реквизита.
//  ДокументОбъект - объект переданного документа.
//  МетаданныеДокумента - Метаданные переданного документа.
//  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
//  если не передано, то возвращается значение Неопределено.
//
// Возвращаемое значение:
//  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
//
Функция ПолучитьРеквизитШапки(ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение = Неопределено) Экспорт

	ЗначениеРеквизита = ?(ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента),
	                      ДокументОбъект[ИмяРеквизита], ПустоеЗначение);

	Возврат ЗначениеРеквизита;

КонецФункции // ПолучитьРеквизитШапки()

// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех таблиц (например значением шапки документа)
//
// Параметры:
//  СтруктТаблицДокумента   - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//  ИмяПоля                 - имя колонки в таблицах локумента, в которую будет установлено новое значение
//  УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
//  СтрТабЧасти             - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
//                            имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
//
Процедура УстановитьЗначениеВТаблицыДокумента(СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = "") Экспорт
	
	СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));
	Для Каждого ТабЧасть Из СтруктТабЧасти Цикл
	
		Если СтруктТаблицДокумента[ТабЧасть.Ключ].Количество() > 0 Тогда
		    СтруктТаблицДокумента[ТабЧасть.Ключ].ЗаполнитьЗначения( УстанавливаемоеЗначение, ИмяПоля);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры // УстановитьЗначениеВТаблицыДокумента()

// Процедура формирует движение в регистр на основании данных в таблицах документов
//
//Параметры:
//  Движение              - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
//  ВидДвижения           - вид движения накопления (приход/расход)
//  СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//  ДатаДвижения          - дата на которую будут формироваться записи
//
Процедура ЗаписатьТаблицыДокументаВРегистр(Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения) Экспорт
	
	Движение.мПериод = ДатаДвижения;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
	
		Если ТабЧасть.Значение.Количество() = 0 Тогда
			Продолжить; // Пропускаем пустые табличные части
		КонецЕсли;
		
		Движение.мТаблицаДвижений = ТабЧасть.Значение;
		Если ВидДвижения = Неопределено Тогда // Регистр сведений
			ВыполнитьДвижениеПоРегистру(Движение);
		Иначе // Регистр накопления
			ВыполнитьДвижениеПоРегистру(Движение, ВидДвижения);
		КонецЕсли;
	
	КонецЦикла;

КонецПроцедуры // ЗаписатьТаблицыДокументаВРегистр()

// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
//
// Параметры:
//  Движение - движение документа (т.е. регистр)
//  СтруктТаблицДокумента - структура содержашая таблицы документа. ключ - имя таблицы, значение - таблица значений с данными документа.
//
// Возвращаемое значение:
//  Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
//  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
//  В таблицы значений данные загружаются по соответствию с имен полей.
//
Функция ЗагрузитьТаблицыДокументаВСтруктуру(Движение, СтруктТаблицДокумента) Экспорт
	
	ПустаяТабРегистра = Движение.Выгрузить();
	ПустаяТабРегистра.Очистить();
	
	СтруктДанных = Новый Структура;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
	
		ТабРегистра = ПустаяТабРегистра.Скопировать();
		
		Если ТабЧасть.Значение <> Неопределено И ТабЧасть.Значение.Количество() > 0 Тогда
			ЗагрузитьВТаблицуЗначений( ТабЧасть.Значение, ТабРегистра);
		КонецЕсли;
		
		СтруктДанных.Вставить( ТабЧасть.Ключ, ТабРегистра);
		
	КонецЦикла;
	
	Возврат СтруктДанных;

КонецФункции // ЗагрузитьТаблицыДокументаВСтруктуру()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

// Функция разбирает строку вида например:
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, МетаданныеОбъекта = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = Найти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = Найти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если МетаданныеОбъекта <> Неопределено Тогда
		Структура.Вставить("Метаданные", МетаданныеОбъекта);
	Иначе
		Если Структура.ТипОбъекта = "Документ" Тогда
			Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
		Иначе
			Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()



Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
	
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	 Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда

		Префикс = "0";

	Иначе

		Префикс = ДокументОбъект.Организация.Префикс;

	КонецЕсли;
	
Конецпроцедуры

Процедура ПриУстановкеНовогоКодаСправочникаПриУстановкеНовогоКода(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	ДобавитьПрефиксУзла(Префикс);
	
КонецПроцедуры



// Функция определяет наличие клиентских подключений к базе других пользователей
Функция ЕстьДругиеПользователиВБазе() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда			
			Возврат Истина;						
		КонецЕсли;		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Функция определяет дату и время начала календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоДекады(ИсходнаяДата) Экспорт

	ДеньМесяца = День(ИсходнаяДата);

	Если ДеньМесяца <= 10 Тогда
		Результат = НачалоМесяца(ИсходнаяДата);
	ИначеЕсли ДеньМесяца <= 20 Тогда
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 10;
	Иначе
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 20;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьНачалоДекады()

// Функция определяет дату и время конца календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецДекады(ИсходнаяДата) Экспорт

	ДеньМесяца = День(ИсходнаяДата);

	Если ДеньМесяца <= 10 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 9);
	ИначеЕсли ДеньМесяца <= 20 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 19);
	Иначе
		Результат = КонецМесяца(ИсходнаяДата);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьКонецДекады()

// Функция определяет дату и время начала полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоПолугодия(ИсходнаяДата) Экспорт

	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = НачалоГода(ИсходнаяДата);
	Иначе
		Результат = ДобавитьМесяц(НачалоГода(ИсходнаяДата), 6);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьНачалоПолугодия()

// Функция определяет дату и время конца полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецПолугодия(ИсходнаяДата) Экспорт

	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = ДобавитьМесяц(КонецГода(ИсходнаяДата), -6);
	Иначе
		Результат = КонецГода(ИсходнаяДата);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьКонецПолугодия()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ УПРАВЛЕНИЯ ПЕРСОНАЛОМ

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	Если ТипОбъекта = Тип("Строка") Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") Тогда 
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект.Наименование)," ");
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"")
	КонецЕсли;
			
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"");

КонецФункции


// Функция собирает паспортные данные физ. лица на указанную дату
//
// Параметры: 
//  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
//  ДатаПериода - дата получения сведений
//
// Возвращаемое значение:
//  Структура с паспортными данными.
//
Функция ПаспортныеДанные(ФизЛицо, ДатаПериода) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);
	Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);

	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ДокументВид        КАК Вид,
	|	ДокументСерия      КАК Серия,
	|	ДокументНомер      КАК Номер,
	|	ДокументДатаВыдачи КАК ДатаВыдачи,
	|	ДокументКемВыдан   КАК Выдан
	|ИЗ
	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо)
	|";

	Шапка = Запрос.Выполнить().Выбрать();
	Шапка.Следующий();

	Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");

	Результат.Вид        = Шапка.Вид;
	Результат.Серия      = Шапка.Серия;
	Результат.Номер      = Шапка.Номер;
	Результат.ДатаВыдачи = Шапка.ДатаВыдачи;
	Результат.Выдан      = Шапка.Выдан;

	Возврат Результат;

КонецФункции // ПаспортныеДанные()

//Процедура для распределения записей из одной таблицы значений по базису (таблица значений или  набору записей)
//Источник 		: ТаблицаЗначений
//Базис 		: ТаблицаЗначений или НаборЗаписей
//Распределение : ключ - поля базиса, значение - поля источника
//Фильтр 		: ключ - поля базиса, значение - поля источника (если не укзан - по совпадающим колонкам)
//Игнорировать  : ключ - поля базиса, значение - поля источника
//Дополнить		: ключ - имя нового поля базиса, значение - значение для заполнения
Функция СформироватьКорректирующиеЗаписи(Источник,Базис,Распределение,Фильтр=неопределено,Игнорировать=Неопределено,Дополнить=Неопределено, НераспределенныеЗаписи_AsIs = ложь) Экспорт
	
	Если ТипЗнч(Базис) = Тип("ТаблицаЗначений") тогда
		Временный_Базис	   = Базис.Скопировать();
	иначе
		Временный_Базис	   = Базис.Выгрузить();
	Конецесли;
	
	КолонкиИсточника = Новый Структура();
	Для Каждого Колонка Из источник.Колонки Цикл
		КолонкиИсточника.Вставить(Колонка.Имя);
	КонецЦикла;
	КолонкиБазиса = Новый Структура();
	Для Каждого Колонка Из Временный_Базис.Колонки Цикл
		Если Не(НЕ ЗначениеЗаполнено(Колонка.Имя)) тогда
			КолонкиБазиса.Вставить(Колонка.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ ЗначениеЗаполнено(Игнорировать) тогда
		 Игнорировать = новый Структура();
	Иначе
		//Зачистим колонки источника и базиса на игнорируемые колонки
		Для Каждого Колонка Из Игнорировать Цикл
			Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
				 КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
			Конецесли;
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				 КолонкиБазиса.Удалить(Колонка.Ключ);
			Конецесли;
		КонецЦикла;
 	КонецЕсли;
	
	//Зачистим колонки источника на распределяемые колонки. Они учитываются отдельно.
	Для Каждого Колонка Из Распределение Цикл
		Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
			 КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
		Иначе
			 Если Источник.Колонки.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено тогда
				 //Не хватает колонок к распределению
				 //Но одну и ту же колонку можно распределить дважды
				 Возврат ложь;
			 КонецЕсли;
		Конецесли;
		Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			 КолонкиБазиса.Удалить(Колонка.Ключ);
		Иначе
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(Дополнить) тогда
		//Проверим на отсутствие дополняемых колонок!
		Для Каждого Колонка Из Дополнить Цикл
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				//Такая колонка уже есть, нельзя добавить новую
				Возврат Ложь;
			Конецесли;
		КонецЦикла;
 	КонецЕсли;
	
	//Если фильтр не задан - по всем совпадающим колонкам
	Если Фильтр=Неопределено тогда
		Фильтр = Новый Структура();
		Для каждого Колонка из КолонкиБазиса цикл
			Если КолонкиИсточника.Свойство(Колонка.Ключ)  и не(Игнорировать.Свойство(Колонка.Ключ)) тогда
				Фильтр.Вставить(Колонка.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Фильтр) тогда
		//Должно быть хоть одно объединяющее поле!
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Колонка Из Фильтр Цикл
		Если не КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	
	//Подготовить сворачивание для источника
	СтрокаСверткиИсточник = ВыгрузитьСтруктуруВСтроку(Фильтр,Истина,КолонкиИсточника);
	Если СтрокаСверткиИсточник = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в источнике!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюИсточник = ВыгрузитьСтруктуруВСтроку(Распределение,Истина);
	Если КолонкиКРаспределениюИсточник = ложь Тогда
		//попытка распределить поле, отсутствующее в источнике!
		Возврат ложь;
	КонецЕсли;
	
	//Подготовить сворачивание для базиса
	СтрокаСверткиБазис = ВыгрузитьСтруктуруВСтроку(КолонкиБазиса,Ложь);
	Если СтрокаСверткиБазис = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в базисе!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюБазис = ВыгрузитьСтруктуруВСтроку(Распределение,Ложь);
	Если КолонкиКРаспределениюБазис = ложь Тогда
		//попытка распределить поле, отсутствующее в базисе!
		Возврат ложь;
	КонецЕсли;
	
	Временный_Источник = Источник.Скопировать();
	
	Временный_Базис.Свернуть(СтрокаСверткиБазис,КолонкиКРаспределениюБазис);
	Временный_Источник.Свернуть(СтрокаСверткиИсточник,КолонкиКРаспределениюИсточник);
	
	НоваяТаблица = новый ТаблицаЗначений();
	Для каждого Колонка из Временный_Базис.Колонки Цикл
		Если Колонка.ТипЗначения.СодержитТип(Тип("Число")) Тогда
			Разрядность = Колонка.ТипЗначения.КвалификаторыЧисла.Разрядность;
			РазрядностьДробнойЧасти = Колонка.ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти;
			КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
			
			ТипЗначения = Новый ОписаниеТипов(Колонка.ТипЗначения,,,КвалификаторЧисла);
		Иначе
			ТипЗначения = Колонка.ТипЗначения;
		КонецЕсли;
		
		НоваяТаблица.Колонки.Добавить(Колонка.Имя, ТипЗначения,,10);
	КонецЦикла;
	
	ТаблицаБазисовРаспределения = Новый ТаблицаЗначений();
	Для каждого Колонка из Распределение Цикл
		ТаблицаБазисовРаспределения.Колонки.Добавить(Колонка.Ключ);
	КонецЦикла;
	
	//установим индексы таблицы для поиска
	СтрокаИндекса = "";
	Для каждого Колонка из Фильтр цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Ключ;
		Иначе
			СтрокаИндекса = СтрокаИндекса + "," + Колонка.Ключ;
		КонецЕсли;
	КонецЦикла;
	Если СтрокаИндекса <> "" Тогда
		Временный_Базис.Индексы.Добавить(СтрокаИндекса);
	КонецЕсли;
	
	Для каждого СтрокаИсточника из Временный_Источник цикл
		Отбор = новый структура();
		Для каждого Колонка из Фильтр цикл
			Отбор.Вставить(Колонка.Ключ,СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)]);
		КонецЦикла;
		СтрокиБазиса = Временный_Базис.НайтиСтроки(Отбор);
		Временный_Базис_СтрокаНераспределеннойЗаписи = Неопределено;
		Если СтрокиБазиса.Количество() = 0 и НераспределенныеЗаписи_AsIs Тогда
			Временный_Базис_СтрокаНераспределеннойЗаписи = Временный_Базис.Добавить();
			ЗаполнитьЗначенияСвойств(Временный_Базис_СтрокаНераспределеннойЗаписи, СтрокаИсточника);
			СтрокиБазиса.Добавить(Временный_Базис_СтрокаНераспределеннойЗаписи);
		КонецЕсли;		
			
		ТаблицаБазисовРаспределения.Очистить();
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаТБР = ТаблицаБазисовРаспределения.Добавить();
			Для каждого Колонка из ТаблицаБазисовРаспределения.Колонки цикл
				ЗаполнитьЗначенияСвойств(СтрокаТБР, Строка);
			КонецЦикла;
		КонецЦикла;
		Для каждого Колонка из Распределение цикл
			РаспределяемаяСумма =  СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)];
			МассивДляРаспределения = ТаблицаБазисовРаспределения.ВыгрузитьКолонку(Колонка.Ключ);
			МассивРезультата = РаспределитьПропорционально(РаспределяемаяСумма, МассивДляРаспределения);
			Если МассивРезультата = неопределено тогда
				ТаблицаБазисовРаспределения.ЗаполнитьЗначения(0,Колонка.Ключ);
			иначе
				ТаблицаБазисовРаспределения.ЗагрузитьКолонку(МассивРезультата,Колонка.Ключ);
			КонецЕсли;
		КонецЦикла;
		
		СтрокаРезультата = 0;
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаНовая = НоваяТаблица.Добавить();
			СрокаРекультатаРаспределения = ТаблицаБазисовРаспределения[СтрокаРезультата];
			СтрокаРезультата = СтрокаРезультата +1;
			Для каждого Колонка из Временный_Базис.Колонки цикл
				Если Распределение.Свойство(Колонка.Имя) тогда
					СтрокаНовая[Колонка.Имя] = СрокаРекультатаРаспределения[Колонка.Имя];
				Иначе
					СтрокаНовая[Колонка.Имя] = Строка[Колонка.Имя];
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		Если не Временный_Базис_СтрокаНераспределеннойЗаписи = Неопределено Тогда
		    Временный_Базис.удалить(Временный_Базис_СтрокаНераспределеннойЗаписи);
		КонецЕсли; 
	КонецЦикла;
	
	Если ЗначениеЗаполнено(Дополнить) тогда
		Для каждого Колонка из Дополнить Цикл
			НоваяТаблица.Колонки.Добавить(Колонка.Ключ,,,10);
			НоваяТаблица.ЗаполнитьЗначения(Колонка.Значение,Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	СтрокиС0Распределением = Новый Массив();
	Для каждого Строка из НоваяТаблица цикл
		СуммаРаспределений0=Истина;
		Для каждого Колонка из распределение цикл
			Если ЗначениеЗаполнено(Строка[Колонка.Ключ]) тогда
				СуммаРаспределений0=Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если СуммаРаспределений0 тогда
			СтрокиС0Распределением.Добавить(Строка);
		Конецесли;
	КонецЦикла;
	Для каждого ПустаяСтрока из СтрокиС0Распределением Цикл 
		НоваяТаблица.Удалить(ПустаяСтрока);
	КонецЦикла;
	
	Возврат НоваяТаблица;
КонецФункции

Функция ВыгрузитьСтруктуруВСтроку(Структура,ПоЗначениям=Ложь,СтруктураПроверки = Неопределено)
	
	НеПроверять = (СтруктураПроверки=Неопределено);
	
	НоваяСтрока = "";
	Для каждого Колонка из Структура Цикл
		Если НеПроверять тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение)или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)+",";
		ИначеЕсли СтруктураПроверки.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение) или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)) тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+",";
		Иначе
			//Нет в проверке!
			возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Если ЗначениеЗаполнено(НоваяСтрока) Тогда
		НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);
	КонецЕсли;
	Возврат НоваяСтрока;
КонецФункции

// Разворачивает таблицу  значений по вложенной таблице
//
// Параметры
//  ТаблицаЗначений  – <ТаблицаЗначений> – базовая таблица
//  КолонкаВложеннойТаблицы  – <Строка> – Наименование колонки влолженной таблицы
//  СписокРаспределяемыхКолонок  – <Структура> – Структура с именами колонок базовой таблицы, значения которых будут распределяться по колонке вложенной таблицы
//         						Ключ - Имя колонки базовой таблицы
//         						Значение - Имя колонки вложенной таблицы. Если во вложенной таблице колонка не обнаружена - обработка прекращается.
// Возвращаемое значение:
//   <ТаблицаЗначений>   – таблица значений, развернутая по значениям вложенной таблицы.
//
// При совпадении имен базовой и вложенной таблиц - если  
Функция РазвернутьПоВложеннойТаблице(ТаблицаЗначений, КолонкаВложеннойТаблицы,СписокРаспределяемыхКолонок, СписокИсключаемыхКолонок, СообщатьОбОшибке = Истина) Экспорт

	Если ТаблицаЗначений.Количество()=0 Тогда
		// Таблица не заполнена, софрмировать новую таблицу не представляется возможнным
		// Отсуттствует вложенная таблица, структуру данных выходной таблицы сформировать невозможно
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке("Отсутствуют строки в базовой таблице, распределение по вложенной таблице невозможно.",,,СтатусСообщения.Внимание);
		КонецЕсли; 
		Возврат Неопределено;
	КонецЕсли; 
	
	КолонкиВложеннойТаблицы = ТаблицаЗначений[0][КолонкаВложеннойТаблицы].Колонки;
	//Заполним значения по тем колонкам, по которым не были заполены значения ранее
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		Если НЕ ЗначениеЗаполнено(Колонка.Значение) Тогда
			СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
		КонецЕсли;
		Если КолонкиВложеннойТаблицы.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено Тогда
			// Во вложенной таблице не обнаружена колонка, по которой производится распределение.
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Во вложенной таблице не обнаружена колонка ("+?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+"), по которой производится распределение.",,,СтатусСообщения.Внимание);
			КонецЕсли; 
			Возврат Неопределено;
		КонецЕсли; 
	КонецЦикла;
	
	НоваяТаблицаЗначений = Новый ТаблицаЗначений();
	Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
	    Если Колонка.Имя = КолонкаВложеннойТаблицы Тогда
			Продолжить;
	    ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого Колонка Из КолонкиВложеннойТаблицы Цикл
		Если не НоваяТаблицаЗначений.Колонки.Найти(Колонка.Имя) = неопределено Тогда
			Продолжить;
		ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 

		ТаблицаДляРаспределения = СтрокаБазовойТаблицы[КолонкаВложеннойТаблицы];

		Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

			СтрокаНовойТаблицы = НоваяТаблицаЗначений.Добавить();

			Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

				Если СписокРаспределяемыхКолонок.Свойство(Колонка.Имя) тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[СписокРаспределяемыхКолонок[Колонка.Имя]];

				ИначеЕсли не КолонкиВложеннойТаблицы.Найти(Колонка.Имя) = Неопределено тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[Колонка.Имя];

				ИначеЕсли Не(ТаблицаЗначений.Колонки.Найти(Колонка.Имя)=Неопределено) тогда
					СтрокаНовойТаблицы[Колонка.Имя] = СтрокаБазовойТаблицы[Колонка.Имя];

				Иначе
					// Колонка не найдена... Неизвестно, как такое может произойти
		  			Если СообщатьОбОшибке Тогда
						СообщитьОбОшибке("при распределении по вложенной таблице невозможно определить значение для колонки :"+Колонка.Имя+".",,,СтатусСообщения.Внимание);
					КонецЕсли; 

				КонецЕсли;

			КонецЦикла; // Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

		КонецЦикла; // Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

	КонецЦикла; // Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
	
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
	КонецЦикла;
	
	// Распределение базовых данных по распределяемым колонкам
	НоваяТаблицаЗначений = СформироватьКорректирующиеЗаписи(ТаблицаЗначений,НоваяТаблицаЗначений,СписокРаспределяемыхКолонок);
	
	Возврат НоваяТаблицаЗначений;

КонецФункции // РазвернутьПоВложеннойТаблице()

// Получает параметр учетной политики (налоговый учет) для заданной организации на заданную дату
//
// Параметры:
//	ИмяПараметра        - строка, имя запрашиваемого параметра учетной политики,
//	Организация         - ссылка на элемент справочника "Организации", для которого надо получить параметры,
//	Дата                - дата, на которую надо получить параметры, если не заполнено, то берется рабочая дата,
//	СтруктураПараметров - структура, содержащая все параметры учетной политики.
//
// Возвращаемое значение:
//	Значение учетной политики
//
Функция УчетнаяПолитикаНалоговыйУчет(ИмяПараметра, Организация, Дата = Неопределено, СтруктураПараметров = Неопределено) Экспорт

	// Если организация не заполнена, то учетная политика неопределена
	Если НЕ ЗначениеЗаполнено(Организация) Тогда
		Возврат Неопределено;
	КонецЕсли;

	// Если дата не заполнена, возьмем рабочую дату
	Если НЕ ЗначениеЗаполнено(Дата) Тогда
		Дата = ПолучитьРабочуюДату();
	КонецЕсли;

	СтруктураПараметров = РегистрыСведений.УчетнаяПолитикаНалоговыйУчет.ПолучитьПоследнее(Дата, Новый Структура("Организация", Организация));

	Если СтруктураПараметров <> Неопределено Тогда
		Результат = СтруктураПараметров[ИмяПараметра];
	Иначе
		СообщитьОбОшибке("Не задан параметр учетной политики (налоговый учет) """ +ИмяПараметра+ """ для организации " + Организация + "!");
		Результат = Ложь;
	КонецЕсли;

	Возврат Результат;

КонецФункции // УчетнаяПолитикаНалоговыйУчет()

// Добавляет записи из таблицы движений в набор записей
// Параметры 
// НаборЗаписей - Набор записей регистра накопления или регистра бухгалтерии
// Таблица - таблица значений содержащая движения соответствующего регистра (таблица движений)
//
Процедура ДобавитьСтрокиВНаборЗаписей(НаборЗаписей, Таблица) Экспорт
	
	НаборМетаданные = НаборЗаписей.Метаданные();
		
	ЭтоРегистрБухгалтерии = (Метаданные.РегистрыБухгалтерии.Найти(НаборМетаданные.Имя)<>Неопределено);
	
	Регистратор = НаборЗаписей.Отбор.Регистратор.Значение;
	
	Период = Неопределено;
	
	Для Каждого Строка Из Таблица Цикл
		
		Запись = НаборЗаписей.Добавить();
			
		ЗаполнитьЗначенияСвойств(Запись,Строка);
			
		Запись.Активность = Истина;

		Если Запись.Период = '00010101' Тогда
			
			Если Период = Неопределено Тогда
			
				СтруктураРеквизитовДокумента = Новый Структура("Дата");
				УправлениеЗапасамиПартионныйУчет.ПолучитьРеквизитыОбъекта(Регистратор, СтруктураРеквизитовДокумента);
				
				Период = СтруктураРеквизитовДокумента.Дата;
			
			КонецЕсли;
			
			Запись.Период = Период;
			
		КонецЕсли;
			
	КонецЦикла;

КонецПроцедуры // ДобавитьСтрокиВНаборЗаписей



// Формирует строку представления документа для сообщений при проведении.
//
// Параметры:
//  СтруктураШапкиДокумента - структура шапки документа.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция ПредставлениеДокументаПриПроведении(СтруктураШапкиДокумента) Экспорт

	Если СтруктураШапкиДокумента.Свойство("ВидОперации") Тогда
		ВидОперацииСтр = " (" + СтруктураШапкиДокумента.ВидОперации + ")";
	Иначе
		ВидОперацииСтр = "";
	КонецЕсли;

	Возврат "Проведение документа: " + СтруктураШапкиДокумента.ПредставлениеДокумента + ВидОперацииСтр;

КонецФункции // ПредставлениеДокументаПриПроведении()

// Проверяет принадлежность документа к видам учета
//
// Параметры: 
//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
//  Отказ                   - флаг отказа в проведении.
//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
	
	Перем Упр, Бух, Нал;
	
	ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);
	ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
	ЕстьНал = СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете", Нал);
	
	Если ЕстьУпр ИЛИ ЕстьБух ИЛИ ЕстьНал Тогда
		Если НЕ МожетБытьТолькоНалоговый Тогда
			Если Упр <> Истина И Бух <> Истина  Тогда
				СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);
			ИначеЕсли Бух <> Истина И Нал = Истина Тогда
				СообщитьОбОшибке("Документ не может проводиться  по налоговому учету, если он не проводится по бухгалтерскому учету." , Отказ, Заголовок);
			КонецЕсли;
		Иначе
			Если Упр <> Истина И Бух <> Истина И Нал <> Истина Тогда
				СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"", ""Бухгалтерский"", ""Налоговый"".", Отказ, Заголовок);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

#Если Клиент Тогда

// Процедура возвращает паспортные данные физлица в виде строки
//
// Параметры: 
//  ФизЛицо - ссылка на элемент справочника "Физические лица",по которму необходимо
//            получить паспортные данные.
//
// Возвращаемое значение:
//  Строка с данными об удостоверении личности физичского лица
//
Функция ПолучитьПаспорныеДанныеСтрокой(ФизЛицо) Экспорт

	СтруктураПаспортныхДанных	= РегистрыСведений.ПаспортныеДанныеФизЛиц.ПолучитьПоследнее(РабочаяДата, Новый Структура("ФизЛицо",ФизЛицо));
	ВидДокумента				= СтруктураПаспортныхДанных.ДокументВид;
	Серия						= СтруктураПаспортныхДанных.ДокументСерия;
	Номер						= СтруктураПаспортныхДанных.ДокументНомер;
	ДатаВыдачи					= СтруктураПаспортныхДанных.ДокументДатаВыдачи;
	КемВыдан					= СтруктураПаспортныхДанных.ДокументКемВыдан;
	НомерПодразделения			= СтруктураПаспортныхДанных.ДокументКодПодразделения;

	Если НЕ (НЕ ЗначениеЗаполнено(ДатаВыдачи)
		   И НЕ ЗначениеЗаполнено(ВидДокумента)
		   И НЕ ЗначениеЗаполнено(Серия + Номер + КемВыдан + НомерПодразделения)) Тогда

		Возврат ?(ВидДокумента.Пустая(),"","" + ВидДокумента + ", ") 
				+ "Серия: " + Серия + ", № " + Номер 
				+ ", Выдан: " + Формат(ДатаВыдачи,"ДФ='дд ММММ гггг'") + " года, " 
				+ КемВыдан + "; № подр. " + НомерПодразделения;

	Иначе
		Возврат "Отсутствуют данные об удостоверении личности."
	КонецЕсли;

КонецФункции // ПолучитьПаспорныеДанныеСтрокой()

#КонецЕсли


Процедура ПриУстановкеКодаПВХПриУстановкеНовогоКода(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	ОбщегоНазначения.ДобавитьПрефиксУзла(Префикс);
	
КонецПроцедуры

Процедура ПриУстановкеНовогоНомераДокументаПриУстановкеНовогоНомера(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ОбщегоНазначения.ДобавитьПрефиксОрганизации(Источник, Префикс);
	ОбщегоНазначения.ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

// Процедура выполняет обработку признака отражения в регламентированном учете для объекта документа.
//
// Параметры:
//  Объект                  - Документ-объект
//  ИмяОтражатьВБУ          - имя элемента формы, связанного с реквизитом ОтражатьВБУ
//  ИмяОтражатьВНУ          - имя элемента формы, связанного с реквизитом ОтражатьВНУ
//  мОтражатьВРегламентированномУчете - переменная формы, передается в процедуру для изменения.
//   далее может использоваться в логике формы в индивидуальном порядке для каждого документа.
//  флИзменятьРеквизитыБУНУ - признак необходимости изменять реквизиты документа ОтражатьвБУ, ОтражатьВНУ
//                            Устанавливается если процедура вызывается при изменении значения организации в документе
Процедура ОбработатьПризнакОтраженияВреглУчете(Объект, ИмяОтражатьВБУ = "ОтражатьВБухгалтерскомУчете",ИмяОтражатьВНУ = "ОтражатьВНалоговомУчете",мОтражатьВРегламентированномУчете,флИзменятьРеквизитыБУНУ=ложь) Экспорт

	мОтражатьВРегламентированномУчете = Объект.Организация.ОтражатьВРегламентированномУчете;

	Если флИзменятьРеквизитыБУНУ или Объект.ЭтоНовый() Тогда
		Если мОтражатьВРегламентированномУчете Тогда
			ТекПользователь = ПараметрыСеанса.ТекущийПользователь;
			//организация в РУ отражается. Флаги БУ и НУ необходимо установить в соотв. с настройками пользователя по умолчанию
			Объект.ОтражатьВБухгалтерскомУчете=УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОтражатьДокументыВБухгалтерскомУчете");
			Если ИмяОтражатьВНУ<>"" Тогда
				Если Объект.ОтражатьВБухгалтерскомУчете Тогда
					Объект.ОтражатьВНалоговомУчете = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОтражатьДокументыВНалоговомУчете");
				Иначе
					Объект.ОтражатьВНалоговомУчете = ложь;
				КонецЕсли;
			КонецЕсли;
		Иначе
			//организация в РУ не отражается - необходимо сбросить флаги отражения в БУ и НУ
			Если Объект.ОтражатьВБухгалтерскомУчете  Тогда
				Объект.ОтражатьВБухгалтерскомУчете = Ложь;
			КонецЕсли;
			Если ИмяОтражатьВНУ<>"" Тогда
				Если Объект.ОтражатьВНалоговомУчете Тогда
					Объект.ОтражатьВНалоговомУчете = Ложь;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ОбработатьПризнакОтраженияВреглУчете()

Функция ОпределитьВозможностьРедактированияОбъекта(Ссылка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ОбъектыЗапрещенныеДляРедактирования.Ссылка
	|ИЗ
	|	РегистрСведений.ОбъектыЗапрещенныеДляРедактирования КАК ОбъектыЗапрещенныеДляРедактирования
	|ГДЕ
	|	ОбъектыЗапрещенныеДляРедактирования.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Если Не Запрос.Выполнить().Пустой() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

//Удалает повторяющиеся элементы массива.
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 

	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМасссиве = Новый Соответствие; 
		БылоНеопределено = Ложь;
		
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента = ТипЗнч(ЭлементМассива); 
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) Тогда
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМасссиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМасссиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// функция определяет есть ли хотя бы одна не цифра в строке
Функция ЕстьНеЦифрыВСтроке(Знач СтрокаПроверки) Экспорт
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Истина;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Ложь;
	
КонецФункции

// Формирует структуру дерева значений, содержащего имена полей, которые
// нужно заполнить в запросе по шапке документа.
//
// Параметры: 
//  Нет.
//
// Возвращаемое значение:
//  Дерево значений.
//
Функция СформироватьДеревоПолейЗапросаПоШапке()  Экспорт

	ДеревоПолейЗапросаПоШапке = Новый ДеревоЗначений;

	ОписаниеТиповСтрока = ОбщегоНазначения.ПолучитьОписаниеТиповСтроки(100);
	
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Объект"   , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Поле"     , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Псевдоним", ОписаниеТиповСтрока);
	
	Возврат ДеревоПолейЗапросаПоШапке;

КонецФункции // СформироватьДеревоПолейЗапросаПоШапке()

// Вставляет строку в дерево полей запроса по шапке, если ее там еще нет,
// если есть, то ничего не делает.
//
// Параметры:
//  ДеревоПолейЗапросаПоШапке - дерево значений, содержащего имена полей, 
//                              которые нужно заполнить в запросе по шапке документа, 
//  ИмяОбъекта                - строка, имя объекта (справочник, регистр и т.д.), 
//  ИмяПоля                   - строка, имя поля объекта,
//  ИмяПсевдонима             - строка, имя псевдонима в запросе поля объекта (необязательный).
//
Процедура ДобавитьСтрокуВДеревоПолейЗапросаПоШапке(ДеревоПолейЗапросаПоШапке, ИмяОбъекта, ИмяПоля, ИмяПсевдонима = Неопределено) Экспорт

	// Поищем нужную строку.
	// Вначале ищем объект.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти(ИмяОбъекта, "Объект");

	Если СтрокаОбъекта = Неопределено Тогда // нужно добавить.
		
		СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Добавить();
		СтрокаОбъекта.Объект    = ИмяОбъекта;
		СтрокаОбъекта.Поле      = ИмяПоля;
		СтрокаОбъекта.Псевдоним = ИмяПсевдонима;


	КонецЕсли;

	// Ищем поле.
	СтрокаПоля = СтрокаОбъекта.Строки. Найти(ИмяПоля,"Поле");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем псевдоним.
	СтрокаПоля = СтрокаОбъекта.Строки.Найти( ИмяПсевдонима, "Псевдоним");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

КонецПроцедуры // ДобавитьСтрокуВДеревоПолейЗапросаПоШапке()

// По переданной структуре полей формирует запрос по табличной части документа.
//
// Параметры: 
//  ДокументОбъект        - объект проводимого документа, 
//  ИмяТабличнойЧасти     - строка, имя табличной части,
//  СтруктураПолей        - структура, ключ структуры содержит псевдоним поля запроса, значение - строку запроса,
//  СтруктураСложныхПолей - структура, ключ структуры содержит псевдоним поля запроса, значение - строку запроса,
//                          необязательный параметр, служит для передачи конструкций типа "ВЫБОР" и т.д.
//
// Возвращаемое значение:
//  Результат запроса.
//
Функция СформироватьЗапросПоТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураПолей,
                                           СтруктураСложныхПолей = Неопределено) Экспорт


	ТекстЗапроса = "";
	
	ДокументМетаданные = ДокументОбъект.Метаданные();

	Для Каждого Реквизит Из СтруктураПолей Цикл

		ТекстЗапроса  = ТекстЗапроса + ",
		|Док." + Реквизит.Значение + 
		" КАК " + СокрЛП(Реквизит.Ключ);

	КонецЦикла;
	
	ТекстСоединение="";
	
	Запрос = Новый Запрос;

	Если ТипЗнч(СтруктураСложныхПолей) = Тип("Структура") Тогда // Добавим к запросу конструкции.
		
		Для Каждого Элемент Из СтруктураСложныхПолей Цикл
			
			ТекстЗапроса  = ТекстЗапроса + ",
			| " + Элемент.Значение + 
			" КАК " + СокрЛП(Элемент.Ключ);
			
		КонецЦикла;
		
		Если СтруктураСложныхПолей.Свойство("Проект") Тогда
			
			ТекстСоединение="
			|ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.УстановкаПроектовДляНоменклатуры.СрезПоследних(&ДатаДок, НоменклатураПроекта В (ВЫБРАТЬ Номенклатура ИЗ Документ." + ДокументМетаданные.Имя + "."+ СокрЛП(ИмяТабличнойЧасти) + " ГДЕ Ссылка = &ДокументСсылка)) КАК ПроектыНоменклатуры
			|ПО Док.Номенклатура=ПроектыНоменклатуры.НоменклатураПроекта";
			
			Запрос.УстановитьПараметр("ДатаДок",ДокументОбъект.Дата);
		КонецЕсли;
	КонецЕсли;
		
	Запрос.Текст = "ВЫБРАТЬ 
				| Док.НомерСтроки " + ТекстЗапроса + "
				| ИЗ 
				|      Документ." + ДокументМетаданные.Имя + "."+ СокрЛП(ИмяТабличнойЧасти) + 
				" КАК Док"+ТекстСоединение+" 
				|     ГДЕ Док.Ссылка = &ДокументСсылка";


	// Установим параметры запроса.
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументОбъект.Ссылка);
	
	Если ДокументОбъект[ИмяТабличнойЧасти].Количество() = 0 Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ГДЕ Док.Ссылка = &ДокументСсылка", "ГДЕ ЛОЖЬ");
	КонецЕсли;

	Возврат Запрос.Выполнить();

КонецФункции // СформироватьЗапросПоТабличнойЧасти()

Функция ПлатформаПоддерживаетТаймаутыСети() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат ОбщегоНазначенияКлиентСервер.СравнитьВерсии(СистемнаяИнформация.ВерсияПриложения, "8.2.16.0") >= 0;
	
КонецФункции
